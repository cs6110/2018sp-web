\lecture{24}
\title{The Polymorphic $\lambda$-Calculus}
\date{20 April 2016}
\maketitle

\section{Recap}

Last lecture we saw how to unify types.
\begin{align*}
\Unify{\emptyset}\ &\definedas\ I\\
\Unify{\alpha=\alpha, E}\ &\definedas\ \Unify E\\
\Unify{\alpha=\tau, E}\ &\definedas\ \{\tau/\alpha\}\cdot\Unify{E\{\tau/\alpha\}},\quad\alpha\notin\FV\tau\\
\Unify{\sigma_1\to\tau_1=\sigma_2\to\tau_2, E}\ &\definedas\ \Unify{\sigma_1=\sigma_2,\tau_1=\tau_2, E}
\end{align*}
where $I$ is the identity substitution $\alpha\mapsto\alpha$. Substitutions are applied from left to right, so the composition $S\,T$ means: do $S$ first, then do $T$.

%\section{Type Checker}
%
%SML code for typechecking is provided on the web site:\\
%\url{http://www.cs.cornell.edu/Courses/cs611/2006fa/lectures/typeCheck.sml}\\
%Feel free to experiment with it.
%
\section{Polymorphic $\lambda$-Calculus}

Suppose we have base types "int" and "bool".
The problem with the simple type inference mechanism that we have presented
is that we do not have quite as much _polymorphism_\footnote{Greek for ``many forms''}
as we would like.
For example, consider a program that binds a variable to the identity
function, then applies it to an "int" and also to a "bool".
\begin{equation}
\letin f{\lam xx}{\ifthenelse{(f~"true")}{(f~3)}{(f~4)}}\label{eqn:polyexample}
\end{equation}
The type checker encounters the "bool" first and says
that the function is of type $"bool\to bool"$, then gives
an error when it sees the "int"
parameter, whereas we really want it to be interpreted
as type $"bool\to bool"$ when applied to a "bool"
parameter and $"int\to int"$ when applied to an "int"
parameter.

We can handle this by introducing a new type constructor that quantifies over types.
\begin{align}
\tau\ &::=\ "int" \bnf "bool" \bnf \alpha \bnf \sigma\to\tau \bnf \fa\alpha\tau\label{eqn:polytypes}
\end{align}
The type $\fa\alpha\tau$ can be viewed as a _polymorphic type_
or _type schema_, a pattern with type variables that can be instantiated
to obtain actual types. For example, the polymorphic type of the identity
function will be the type schema
\begin{gather*}
\fa\alpha{\alpha\to\alpha}
\end{gather*}
and the type of the $K$ combinator $\lam{xy}x$ will be
\begin{gather*}
\fa\alpha{\fa\beta{\alpha\to\beta\to\alpha}}.
\end{gather*}
There will be rules that allow us to delay the instantiation of the type
variables until the function is applied. Thus we can interpret the identity
function as $"int\to int"$ or $"bool\to bool"$ depending on context.

The resulting language is called the \emph{polymorphic $\lambda$-calculus}.
In this new language, the terms and evaluation rules are the same, but the
types are defined by \eqref{eqn:polytypes}. All the terms that were previously
well-typed will still be well-typed, but there will be more well-typed terms
than before; for example, \eqref{eqn:polyexample}.

\section{Typing Rules}

In addition to the old typing rules
\begin{align*}
& \judge\Gamma n{"int"}\quad\mbox{(and similarly for other constants)}
&& \judge{\Gamma,\,x:\tau}x\tau\\[1em]
& \dfrac{\judge\Gamma e{\sigma\to\tau}\quad\judge\Gamma d\sigma}{\judge\Gamma{(e~d)}\tau}
&& \dfrac{\judge{\Gamma,\,x:\sigma}e\tau}{\judge\Gamma{\lam xe}{\sigma\to\tau}}
\end{align*}
%\begin{gather*}
%\begin{array}c
%\judge\Gamma n{"int"}\quad\mbox{(and similarly for other constants)} \qquad
%\judge{\Gamma,\,x:\tau}x\tau\\[1em]
%\dfrac{\judge\Gamma e{\sigma\to\tau}\quad\judge\Gamma d\sigma}{\judge\Gamma{(e~d)}\tau} \qquad
%\dfrac{\judge{\Gamma,\,x:\sigma}e\tau}{\judge\Gamma{\lam xe}{\sigma\to\tau}}
%\end{array}
%\end{gather*}
we add the following two new rules for polymorphic types:
\begin{align*}
&
\AxiomC{$\judge\Gamma e\tau\quad$}
\RightLabel{\small $(\alpha\notin\FV\Gamma)$}
\UnaryInfC{$\judge\Gamma e{\fa\alpha\tau}$}
\DisplayProof
&&
\AxiomC{$\judge\Gamma e{\fa\alpha\tau}$}
\UnaryInfC{$\judge\Gamma e{\subst\tau\sigma\alpha}$}
\DisplayProof
\end{align*}
These are called the _generalization rule_ and the _instantiation rule_, respectively.

The notation $\subst\tau\sigma\alpha$ refers to the safe substitution of the type $\sigma$ for the type variable $\alpha$ in $\tau$. Here the binding operator $\forall\alpha$ binds the type variable $\alpha$ in the same way that $\lambda x$ binds the variable $x$ in $\lambda$-terms, and the notions of scope, free and bound variables are the same. In particular, one can $\alpha$-convert type variables as necessary to avoid the capture of free type variables when performing substitutions.

The generalization rule includes the side condition $\alpha\notin\FV\Gamma$. The idea here is that the type judgment $\judge\Gamma e\tau$ must hold without any assumptions involving $\alpha$; if so, then we can conclude that $\alpha$ could have been any type $\sigma$, and the type judgment $\judge\Gamma e{\subst\tau\sigma\alpha}$ would also hold.

\section{Examples}

Here is a derivation of the polymorphic type of $K$ in this system.
\begin{center}
\mbox{}
\infer{\judge{}{\lam x{\lam yx}}{\fa\alpha{\fa\beta{\alpha\to\beta\to\alpha}}}}
   {\infer{\judge{}{\lam x{\lam yx}}{\fa\beta{\alpha\to\beta\to\alpha}}}
       {\infer{\judge{}{\lam x{\lam yx}}{\alpha\to\beta\to\alpha}}
          {\infer{\judge{x:\alpha}{\lam yx}{\beta\to\alpha}}
              {\judge{x:\alpha,\,y:\beta}x\alpha}}}}
\end{center}
Starting from $\judge{x:\alpha,\,y:\beta}x\alpha$, two applications of the abstraction rule yield $\judge{}{\lam x{\lam yx}}{\alpha\to\beta\to\alpha}$, then two applications of the generalization rule yield $\judge{}{\lam x{\lam yx}}{\fa\alpha{\fa\beta{\alpha\to\beta\to\alpha}}}$.

Some terms are typable in this system that were not typable before.
For example, the term $\lam x{xx}$ is typable:
\begin{center}
\mbox{}
\infer{\judge{}{\lam x{xx}}{\fa\beta{(\fa\alpha\alpha)\to\beta}}}
   {\infer{\judge{}{\lam x{xx}}{(\fa\alpha\alpha)\to\beta}}
      {\infer{\judge{x:\fa\alpha\alpha}{xx}{\beta}}
         {\infer{\judge{x:\fa\alpha\alpha}x{\alpha\to\beta}}
            {\judge{x:\fa\alpha\alpha}x{\fa\alpha\alpha}}
         &
         \infer{\judge{x:\fa\alpha\alpha}x{\alpha}}
            {\judge{x:\fa\alpha\alpha}x{\fa\alpha\alpha}}}}}
\end{center}
Unfortunately, this type is not too meaningful, because _nothing_ has type $\fa\alpha\alpha$. This type is said to be _uninhabited_, and we give it a name: "Void". However, by a similar argument, we can show that $\lam x{xx}$ also has type $\fa\beta{(\fa\alpha{\alpha\to\alpha})\to{(\beta\to\beta)}}$, which _is_ meaningful.
\begin{center}
\mbox{}
\infer{\judge{}{\lam x{xx}}{\fa\beta{(\fa\alpha{\alpha\to\alpha})\to{(\beta\to\beta)}}}}
   {\infer{
      \judge{}{\lam x{xx}}{(\fa\alpha{\alpha\to\alpha})\to{(\beta\to\beta)}}}
      {\infer{\judge{x:\fa\alpha{\alpha\to\alpha}}{xx}{{\beta\to\beta}}}
         {\infer{\judge{x:\fa\alpha{\alpha\to\alpha}}x{{(\beta\to\beta)}\to{(\beta\to\beta)}}}
            {\judge{x:\fa\alpha{\alpha\to\alpha}}x{\fa\alpha{\alpha\to\alpha}}}
         &
         \infer{\judge{x:\fa\alpha{\alpha\to\alpha}}x{\beta\to\beta}}
            {\judge{x:\fa\alpha{\alpha\to\alpha}}x{\fa\alpha{\alpha\to\alpha}}}}}}
\end{center}

Although $\lam x{xx}$ is typable, the paradoxical combinator $\Omega = (\lam x{xx})\,(\lam x{xx})$ is not, and neither is the $Y$ combinator. This is because the language is still strongly normalizing. This means that the polymorphic $\lambda$-calculus is not Turing complete, that is, it cannot simulate arbitrary Turing machines.

Worse, types inference is undecidable, so the programmer must sometimes provide types.

\section{Let-Polymorphism}

We can regain decidability of type inference by placing some restrictions on the use of the type quantifier $\forall\alpha$. Specifically, we will only allow it at the top level; that is, we will only allow polymorphic type expressions of the form $\fa{\alpha_1\ldots\forall\alpha_n}\tau$, where $\tau$ is quantifier-free:
\begin{align*}
& \text{quantifier-free terms} & \tau\ &::=\ "int" \bnf "bool" \bnf \alpha \bnf \tau_1\to\tau_2\\
& \text{polymorphic terms} & \pi\ &::=\ \tau \bnf \fa\alpha\pi
\end{align*}
We will also modify our rules so that it can only be introduced in the context of a "let" statement. Thus we will modify our definition of terms to include a "let" statement:
\begin{align*}
e\ &::=\ \cdots \bnf \letin x{e_1}{e_2}
\end{align*}
and replace the generalization rule with the "let" rule
\begin{align*}
\AxiomC{$\judge\Gamma d\sigma$}
\AxiomC{$\judge{\Gamma,\,x:\fa{\alpha_1\ldots\forall\alpha_n}\sigma}e\tau$}
\RightLabel{\small $(\{\alpha_1,\ldots,\alpha_n\}=\FV\sigma-\FV\Gamma)$}
\BinaryInfC{$\judge\Gamma{\letin xde}\tau$}
\DisplayProof
\end{align*}
So type schemas are only used to type "let" expressions.
For this reason, this approach is called \emph{let-polymorphism}.

The type systems of OCaml and Haskell are based on "let"-polymorphism. We previously
considered the expression $\letin xde$ to be syntactic sugar for $(\lam xe)\,d$, but in OCaml,
the former may be typable in some cases when the latter is not:

\begin{code}
\tt
  \# let f = fun x -> x in if (f true) then (f 3) else (f 4);;
  - : int = 3
  \# (fun f -> if (f true) then (f 3) else (f 4)) (fun x -> x);;
  Error: This expression has type int but an expression was expected of type
       bool
\end{code}
In theory, "let"-polymorphism can cause the type checker to run in exponential time, but in practice
this is not a problem.

\section{System F}

In the Church-style simply-typed $\lambda$-calculus, we annotated binding
occurrences of variables with their types. The corresponding version
of the polymorphic $\lambda$-calculus is called _System F_. Here we
explicitly abstract terms with respect to types and explicitly instantiate
by applying an abstracted term to a type. We augment the syntax with
new terms and types:
\begin{align*}
e\ &::=\ \cdots \bnf \Lam\alpha e \bnf e~\tau
& \tau\ &::=\ b \bnf \tau_1 \to \tau_2 \bnf \alpha \bnf \fa\alpha\tau
\end{align*}
where $b$ are the base types (e.g., "int" and "bool").
The new terms are _type abstraction_ and _type
application_, respectively. Operationally, we have
\begin{align}
(\Lam\alpha e)\,\tau\ &\to\ \subst e\tau\alpha.\label{eq:instantiate}
\end{align}
This just gives the rule for instantiating a type schema. Since these
reductions only affect the types, they can be performed at compile time.

The typing rules for these constructs need a notion of well-formed
type. We introduce a new environment $\Delta$ that maps type variables
to their _kinds_. For now, there is only one kind, namely "type", so
$\Delta$ is a partial function with finite domain mapping type variables to $\{"type"\}$.
Since the range is only a singleton, all $\Delta$ does for now
is to specify a set of types, namely $\dom\Delta$ (it will get more
complicated later). As before, we use the notation $\Delta,\,\alpha:"type"$
for the partial function $\Delta["type"/\alpha]$.
For now, we just abbreviate this by $\Delta,\,\alpha$.

The type system has two classes of judgments:
\begin{align*}
& \judge\Delta\tau{"type"} && \Judge\Delta\Gamma e\tau
\end{align*}
For now, we just abbreviate the former by $\Delta\force\tau$. These judgments
just determine when $\tau$ is well-formed under the assumptions $\Delta$.
The typing rules for this class of judgments are:
\begin{align*}
& \Delta,\,\alpha\force\alpha
&& \Delta\force b
&&
\AxiomC{$\Delta\force\sigma$}
\AxiomC{$\Delta\force\tau$}
\BinaryInfC{$\Delta\force\sigma\to\tau$}
\DisplayProof
&&
\AxiomC{$\Delta,\,\alpha\force\tau$}
\UnaryInfC{$\Delta\force\fa\alpha\tau$}
\DisplayProof
\end{align*}
Right now, all these rules do is use $\Delta$ to keep track
of free type variables. One can show that $\Delta\force\tau$ iff
$\FV\tau\subseteq\dom\Delta$.

The typing rules for the second class of judgments are:
\begin{gather*}
\begin{array}c
\begin{array}{c@{\hspace{1cm}}c@{\hspace{1cm}}c}
\AxiomC{$\Delta\force\tau$}
\UnaryInfC{$\Judge\Delta{\Gamma,\,x:\tau}x\tau$}
\DisplayProof
&
\AxiomC{$\Judge\Delta\Gamma{e_0}{\sigma\to\tau}$}
\AxiomC{$\Judge\Delta\Gamma{e_1}{\sigma}$}
\BinaryInfC{$\Judge\Delta\Gamma{(e_0\,e_1)}\tau$}
\DisplayProof
&
\AxiomC{$\Judge\Delta{\Gamma,\,x:\sigma}e{\tau}$}
\AxiomC{$\Delta\force\sigma$}
\BinaryInfC{$\Judge\Delta\Gamma{(\lam{x:\sigma}e)}{\sigma\to\tau}$}
\DisplayProof
\end{array}\\[14pt]
\begin{array}{c@{\hspace{1cm}}c}
\AxiomC{$\Judge\Delta\Gamma e{\fa\alpha\tau}$}
\AxiomC{$\Delta\force\sigma$}
\BinaryInfC{$\Judge\Delta\Gamma{(e\,\sigma)}{\subst\tau\sigma\alpha}$}
\DisplayProof
&
\AxiomC{$\Judge{\Delta,\,\alpha}\Gamma e\tau$}
\RightLabel{\small $(\alpha\notin\FV\Gamma)$}
\UnaryInfC{$\Judge\Delta\Gamma{(\Lam\alpha e)}{\fa\alpha\tau}$}
\DisplayProof
\end{array}
\end{array}
\end{gather*}
One can show that if $\Judge\Delta\Gamma e\tau$ is derivable, then $\tau$ and all types occurring in annotations in $e$ are well-formed. In particular, $\judge{}e\tau$ only if $e$ is a closed term and $\tau$ is a closed type, and all type annotations in $e$ are closed types.

For example, the polymorphic identity function is $\Lam\alpha{\lam{\type x\alpha}x}$, which has polymorphic type $\fa\alpha{\alpha\to\alpha}$ according to the following proof:
\begin{align*}
\AxiomC{$\alpha\force\alpha$}
\UnaryInfC{$\Judge{\alpha}{\type x\alpha}x\alpha$}
\AxiomC{$\alpha\force\alpha$}
\BinaryInfC{$\Judge{\alpha}{}{(\lam{\type x\alpha}x)}{\alpha\to\alpha}$}
\UnaryInfC{$\judge{}{(\Lam\alpha{\lam{\type x\alpha}x})}{\fa\alpha{\alpha\to\alpha}}$}
\DisplayProof
\end{align*}
To apply this function to a value of a particular type, one must explicitly instantiate the type using \eqref{eq:instantiate}:
\begin{align*}
((\Lam\alpha{\lam{\type x\alpha}x})\ "int")\ 3\ &\to\ ({\lam{\type x{"int"}}x})\ 3\ \to\ 3.
\end{align*}
