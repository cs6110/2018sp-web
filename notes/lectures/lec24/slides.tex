\documentclass[landscape]{slides} 
\usepackage{times,amssymb,latexsym,amsmath,graphics,proof,color,eucal,dk}
\special{landscape}
%\topmargin=-4cm
%\oddsidemargin=2cm
\textwidth=20cm
\pagestyle{empty}
\definecolor{green}{rgb}{0,.5,.25}
\newcommand\red[1]{\color{red}#1\color{black}}
\newcommand\blue[1]{\color{blue}#1\color{black}}
\newcommand\green[1]{\color{green}#1\color{black}}
\newcommand\black[1]{\color{black}#1\color{black}}

\newcommand\sbst[2]{#2\subst{\bar x}{#1}}
\newcommand\frad[2]{\displaystyle\frac{#1}{#2}}
\newcommand\publishname{\ensuremath{\mathrm{publish}}}
\newcommand\cytename{\ensuremath{\mathrm{cite}}}
\newcommand\publish[1]{\publishname(#1)}
\newcommand\cyte[3]{\cytename(#1,#2,#3)}
\newcommand\assume[2]{\mathrm{assume}(#1,#2)}
\newcommand\ident[2]{\mathrm{ident}(#1,#2)}

\newcommand\sep{\;;\;}
\newcommand\GT{\LL}
\newcommand\GTA[1]{\GT\sep #1}
\newcommand\GoT[1]{\LL,#1}
\newcommand\GoTA[2]{\GoT{#1}\sep #2}

\newcommand\task[2]{{#1}\mathrel\force{#2}}
\newcommand\ax{\mathsf{axiom}_\phi}
\newcommand\pubname{\mathsf{pub}}
\newcommand\pub[1]{\pubname\:{#1}}
\newcommand\refl{\ensuremath{\mathsf{ref}}}
\newcommand\symm{\ensuremath{\mathsf{sym}}}
\newcommand\trans{\ensuremath{\mathsf{trans}}}
\newcommand\congf{\ensuremath{\mathsf{cong}_f}}

\def\xinfer[#1]#2#3{\infer[\mbox{{#1}}]{#2}{#3}}
\def\xinfers[#1]#2#3{\infer*[\mbox{{#1}}]{#2}{#3}}
\def\comp#1#2{{#1}\mathrel{;}{#2}}
\def\judge#1#2{{#1}\mathrel\force{#2}}
\def\njudge#1#2{{#1}\mathrel\nvdash{#2}}
\def\frat#1#2{\displaystyle\frac{#1}{#2}}
\def\lleq{\sqsubseteq}
\def\eqv#1{#1/\mbox{$\equiv$}}
\def\plus{^+}

\begin{document}

\begin{slide}
\color{black}%
\begin{small}
\begin{verbatim}
type var = string
datatype tipe = TypeVar of var | Int | Bool | Arrow of tipe * tipe
                | Subst of tipe ref
datatype term = Var of var | Num of int | TruthVal of bool
                | App of term * term | Lambda of var * term

val freshType : unit -> tipe =
let val counter = ref 0 in
  fn() => (
    counter := !counter + 1;
    Subst(ref(TypeVar("alpha" ^ Int.toString(!counter))))
  )
end

fun resolve(t:tipe):tipe =
case t of
  Subst(ref(TypeVar _)) => t
| Subst(r as ref t') =>
    let val t'' = resolve(t') in (r := t''; t'') end
| _ => t
\end{verbatim}
\end{small}
\end{slide}

\begin{slide}
\color{black}%
\begin{small}
\begin{verbatim}
fun occurs(a:var, t:tipe):bool =
case resolve t of
  Int => false
| Bool => false
| Arrow(t1,t2) => occurs(a,t1) orelse occurs(a,t2)
| Subst(ref (TypeVar b)) => a = b
| Subst(ref t1) => occurs(a,t1)
| _ => raise Fail "Error"

fun extend(Gamma, x, t:tipe) =
  fn (y:var) => if y=x then t else Gamma y

val base = fn (y:var) => raise Fail "lookup error"
\end{verbatim}
\end{small}
\end{slide}

\begin{slide}
\color{black}%
\begin{small}
\begin{verbatim}
fun unify(t1, t2) =
case(resolve(t1), resolve(t2)) of
  (Int, Int) => ()
| (Bool, Bool) => ()
| (Arrow(t1, t2), Arrow(t3, t4)) => (unify(t1, t3); unify(t2, t4))
| (Subst(r as ref (TypeVar a)), Subst(s as ref (TypeVar b)))
    => if a = b then () else r := Subst s
| (Subst(r as ref (TypeVar a)), t2)
    => if occurs(a,t2) then raise Fail "occurs check" else r := t2
| (t1, Subst(r as ref (TypeVar a)))
    => if occurs(a,t1) then raise Fail "occurs check" else r := t1
| _ => raise Fail "cannot unify"
\end{verbatim}
\end{small}
\end{slide}

\begin{slide}
\color{black}%
\begin{small}
\begin{verbatim}
fun tcheck(Gamma, e):tipe =
case e of
  Num n => Int
| TruthVal b => Bool
| Var x => Gamma x
| App(e0,e1) =>
    let
      val t0 = tcheck(Gamma, e0)
      val t1 = tcheck(Gamma, e1)
      val T2 = freshType()
    in
      (unify(t0, Arrow(t1, T2)); T2)
    end
| Lambda(x, e) =>
    let
      val T1 = freshType()
      val t2 = tcheck(extend(Gamma, x, T1), e)
    in
      Arrow(T1, t2)
    end
\end{verbatim}
\end{small}
\end{slide}

\begin{slide}
\color{black}%
\begin{small}
\begin{verbatim}
fun collapse(t:tipe):tipe =
case resolve t of
  Int => Int
| Bool => Bool
| Arrow(t1,t2) => Arrow(collapse(t1),collapse(t2))
| Subst(ref t') => collapse t'
| TypeVar a => t

fun typeCheck(e):tipe = collapse(tcheck(base, e))

(* examples *)

val const3 = Lambda("x",Num 3)
val I = Lambda("x",Var "x")
val K = Lambda("x",Lambda("y",Var "x"))
val S = Lambda("x", Lambda("y", Lambda("z",
                 App(App(Var "x",Var "z"),App(Var "y",Var "z")))))
val Omega = App(Lambda("x",App(Var "x", Var "x")),
                Lambda("x",App(Var "x", Var "x")))
\end{verbatim}
\end{small}
\end{slide}

\end{document}
