\lecture{14}
\title{Continuations}
\maketitle

\section{Continuation-Passing Style}

Consider the statement $\ifthenelse{x\le 0}{x}{x+1}$.  We can think of
this as $(\lam y{\ifthenelse yx{x+1}})\,(x\le 0)$.  To evaluate this,
we would first evaluate the argument $x\le 0$ to obtain a Boolean
value, then apply the function $\lam y{\ifthenelse yx{x+1}}$ to this
value.  The function $\lam y{\ifthenelse yx{x+1}}$ is called a {\em
continuation}, because it specifies what is to be done with the result
of the current computation in order to continue the computation.

Given an expression $e$, it is possible to transform the expression
into a function that takes a continuation $k$ and applies it to the
value of $e$.  The transformation is applied recursively.  This is
called \emph{continuation-passing style} (CPS).  There are a number of
advantages to this style:
\begin{itemize}
\item
The resulting expressions have a much simpler evaluation semantics,
since the sequence of reductions to be performed is specified by a
series of continuations.  The next reduction to be performed is always
uniquely determined, and the remainder of the computation is handled
by a continuation.  Thus evaluation contexts are not necessary to
specify the evaluation order.
\item
In practice, function calls and function returns can be handled in a
uniform way.  Instead of returning, the called function simply calls
the continuation.
\item
In a recursive function, any computation to be performed on the value
returned by a recursive call can be bundled into the continuation.
Thus every recursive call becomes tail-recursive.  For example, the
factorial function
\(
"fact"\,n &=& \ifthenelse{n=0}{1}{n*"fact"\,(n-1)}
\)
becomes
\(
"fact"'\,n\,k &=& \ifthenelse{n=0}{k\,1}{"fact"'\,(n-1)\,(\lam v{k\,(n*v)})}.
\)
One can show inductively that $"fact"'\,n\,k = k\,("fact"\,n)$,
therefore $"fact"'\,n\,\lam xx = "fact"\,n$.  This transformation
effectively trades stack space for heap space in the implementation.
\item
Continuation-passing gives a convenient mechanism for non-local flow
of control, such as goto statements and exception handling.
\end{itemize}

\section{CPS Semantics}

Our grammar for the $\lambda$-calculus was:
\begin{eqnarray*}
e &::=& x \bnf \lam xe \bnf e_0\,e_1 
\end{eqnarray*}
Our grammar for the CPS $\lambda$-calculus will be:
\begin{eqnarray*}
v\ \ ::=\ \ x \bnf \lam xe &\qquad& e\ \ ::=\ \ v_0\,v_1\,\cdots\,v_n
\end{eqnarray*}
This is a highly constrained syntax.  Barring reductions inside the
scope of a $\lambda$-abstraction operator, the expressions $v$ are all
irreducible.  The only reducible expression is
$v_0\,v_1\,\cdots\,v_n$.  If $n\geq 1$, there exactly one redex
$v_0\,v_1$, and both the function and the argument are already fully
reduced.  The small step semantics has a single rule
\(
(\lam xe)\,v &\rightarrow& \subst evx,
\)
and we do not need any evaluation contexts.

The big step semantics is also quite simple, with only a single rule:
\[
\frac{\subst evx \stepsto v'}{(\lam xe)\,v \stepsto v'}.
\]
The resulting proof tree will not be very tree-like.  The rule has one
premise, so a proof will be a stack of inferences, each one
corresponding to a step in the small-step semantics.  This allows for
a much simpler interpreter that can work in a straight line rather
than having to make multiple recursive calls.

The fact that we can build a simpler interpreter for the language is a
strong hint that this language is lower-level than the
$\lambda$-calculus.  Because it is lower-level (and actually closer to
assembly code), CPS is typically used in functional language compilers
as an intermediate representation. It also is a good code
representation if one is building an interpreter.

\section{CPS Conversion}

Despite the restricted syntax of CPS, we have not lost any expressive
power.  Given a $\lambda$-calculus expression $e$, it is possible to
define a translation $\SB e$ that translates it into CPS.  This
translation is known as _CPS conversion_. It was first described by
John Reynolds.  The translation takes an arbitrary $\lambda$-term $e$
and produces a CPS term $\SB e$, which is a function that takes a
continuation $k$ as an argument.  Intuitively, $\SBk e$ applies $k$ to
the value of $e$.

We want our translation to satisfy $e\goesto *{\mathrm{CBV}} v$ iff
$\SBk e\goesto *{\mathrm{CPS}} \SBk v$ for primitive values $v$ and
any variable $k\notin\FV e$, and $e\Uparrow_{\mathrm{CBV}}$ iff $\SBk
e \Uparrow_{\mathrm{CPS}}$.

The translation is (adding numbers as primitive values):
\(
\SBk n &\definedas& k\,n\\
\SBk x &\definedas& k\,x \\
\SBk{\lam xe} &\definedas& k\,(\lam x{\SB e})\ \ =\ \ k\,(\lam{xk'}{\SBA e{k'}})\\
\SBk{e_0\,e_1} &\definedas& \SB{e_0}(\lam f{\SB{e_1}(\lam v{fvk})}).
\)
(Recall $\SBk e \definedas e'$ really means $\SB e \definedas \lam k{e'}$.)

\subsection{An Example}

In the CBV $\lambda$-calculus, we have
\(
(\lam{xy}x)\,1 &\rightarrow& \lam y1
\)
Let's evaluate the CPS-translation of the left-hand side using the CPS evaluation rules.
\(
\SBk{(\lam{xy}x)\,1}
&=& \SB{\lam x{\lam yx}}(\lam f{\SB 1(\lam v{fvk})})\\
&=& (\lam f{\SB 1(\lam v{fvk})})\,(\lam x{\SB{\lam yx}})\\
&\rightarrow& \SB 1(\lam v{(\lam x{\SB{\lam yx}})\,v\,k})\\
&=& (\lam v{(\lam x{\SB{\lam yx}})\,v\,k})\,1\\
&\rightarrow& (\lam x{\SB{\lam yx}})\,1\,k\\
&\rightarrow& \SBk{\lam y1}.
\)

\section{CPS and Strong Typing}

Now let us use CPS semantics to augment our previously defined \FL\
language translation so that it supports runtime type checking.  This
time our translated expressions will be functions of $\rho$ and $k$
denoting an environment and a continuation, respectively.  The term
$\SBB[E]e\rho k$ represents a program that evaluates $e$ in the
environment $\rho$ and sends the resulting value to the continuation
$k$.

As before, assume that we have an encoding of variable names $x$ and a
representation of environments $\rho$ along with lookup and update
functions $\lookup\rho x$ and $\update\rho vx$.

In addition, we want to catch type errors that may occur during
evaluation.  As before, we use integer tags to keep track of types:
\begin{align*}
"Err"\ &\definedas\ 0 & "Null"\ &\definedas\ 1 & "Bool"\ &\definedas\ 2 &
"Num"\ &\definedas\ 3 & "Pair"\ &\definedas\ 4 & "Fun"\ &\definedas\ 5
\end{align*}
%
%\[
%\begin{array}{ll@{\hspace{1cm}}ll@{\hspace{1cm}}ll}
%\mbox{booleans} & 0 & \mbox{empty list} & 2 & \mbox{functions} & 4\\
%\mbox{integers} & 1 & \mbox{pairs} & 3 & \mbox{error} & 5
%\end{array}
%\]
A \emph{tagged value} is a value paired with its type tag; for
example, $("Bool","true")$.  Using these tagged values, we can now
define a translation that incorporates runtime type checking:
\begin{eqnarray*}
\SBB[E] x\rho k &\definedas& k\,(\lookup\rho x)\\
\SBB[E] b\rho k &\definedas& k\,("Bool",b)\\
\SBB[E] n\rho k &\definedas& k\,("Num",n)\\
%\SBB[E]{"nil"}\rho k &\definedas& k\,("Null",0)\\
\SBB[E]{()}\rho k &\definedas& k\,("Null","nil")\\
%\SBB[E]{(e_0,e_1)}\rho k &\definedas& \SBB[E]{e_0}\rho{(\lam{x_0}{\SBB[E]{e_1}\rho{(\lam{x_1}{k\,("Pair",(x_0,x_1))})}})}\\
\SBB[E]{(\seq e1n)}\rho k &\definedas& \SBB[E]{e_1}\rho{(\lam{x_1}{\SBB[E]{(\seq e2n)}\rho{(\lam{x_2}{k\,("Pair",(x_1,x_2))})}})},\ n\geq 1\\
\SBB[E]{\letin x{e_1}{e_2}}\rho k &\definedas& \SBB[E]{e_1}\rho{(\lam p{\SBB[E]{e_2}{(\update\rho px)}k})}\\
\SBB[E]{\lam xe}\rho k &\definedas& k\,("Fun",\lam{vk'}{\SBB[E]e{(\update\rho vx)}k'})\\
\SBB[E]{"error"}\rho k &\definedas& k\,("Err",0).
\end{eqnarray*}
Now a function application can check that it is actually applying a function:
\begin{eqnarray*}
\SBB[E]{e_0\,e_1}\rho k &\definedas& \SBB[E]{e_0}\rho{(\lam p{\letin{(t,f)}p{\ifthenelse{t\neq "Fun"}{k\,("Err",0)}{\SBB[E]{e_1}\rho{(\lam v{fvk})}}}})}
\end{eqnarray*}
We can simplify this by defining a helper function "check-fn":
\(
"check\hyphen fn" &\definedas& \lam{kp}{\letin{(t,f)}p{\ifthenelse{t\neq "Fun"}{k\,("Err",0)}{kf}}}.
\)
The helper function takes in a continuation and a tagged value, checks the type, strips off the tag, and passes the raw (untagged) value to the continuation.  Then
\(
\SBB[E]{e_0\,e_1} \rho k &\definedas& \SBB[E]{e_0}\rho{("check\hyphen fn"\,(\lam f{\SBB[E]{e_1}\rho{(\lam v{fvk})}}))}.
\)
Similarly,
\(
\SBB[E]{\ifthenelse{e_0}{e_1}{e_2}}\rho k &\definedas& 
\SBB[E]{e_0}\rho{({"check\hyphen bool"\,(\lam b{\ifthenelse b{\SBB[E]{e_1}\rho k}{\SBB[E]{e_2}\rho k}})})}\\
\SBB[E]{\#n\,e}\rho k &\definedas& \SBB[E] e\rho{({"check\hyphen pair"\,(\lam t{k\,(\#n\,t)})})}.
\)

%Compile-time optimizations:
%\(
%\update{(\update\rho x u)}y v &\rightarrow& \update{(\update\rho y v)}x u\\
%\update{(\update\rho x u)}x v &\rightarrow& \update\rho x v\\
%\lookup{(\update\rho x v)}x &\rightarrow& v.
%\)

\section{CPS Semantics for \FL!}

\subsection{Syntax}

Since \FL! has references, we need to add a store $\sigma$ to our
notation. Thus we now have translations with the form $\SBC[E]e\rho
k\sigma$, which means, ``Evaluate $e$ in the environment $\rho$ with
store $\sigma$ and send the resulting value and the new store to the
continuation $k$.''  A continuation is now a function of a value and a
store; that is, a continuation $k$ should have the form
$\lam{v\sigma}{\cdots}$\,.

The translation is:
\begin{itemize}
\item Variable: $\SBC[E]x\rho k\sigma \definedas k\,(\lookup\rho x)\,\sigma$.

If we think about this translation as a function and $\eta$-reduce away the $\sigma$, we obtain
\begin{align*}
\SBB[E]x \rho k\ &=\ \lam\sigma{k\,(\lookup\rho x)\,\sigma}\ =\ k\,(\lookup\rho x).
\end{align*}
\end{itemize}
Note that in the $\eta$-reduced version, we have the same translation
that we for \FL.  In general, any expression in \FL! that is
not state-aware can be $\eta$-reduced to the same translation as \FL.
Thus in order to translate to \FL!, we need to add
translation rules only for the functionality that is state-aware.

We assume that we have a type tag "Loc" for locations and "check-loc" for
tagging values as locations and checking those tags.  We also assume that we have extended our "lookup" and "update" functions to apply to stores.
\(
\SBC[E]{"ref"\,e}\rho k\sigma &\definedas&
\SBC[E]e\rho{(\lam{v\sigma'}{\letin{(\ell,\sigma'')}{("malloc"\,\sigma'\,v)}{k\,("Loc",\,\ell)\,\sigma''}})}\sigma\\
\SBB[E]{!e}\rho k &\definedas&
\SBB[E]e\rho{("check\hyphen loc"\,(\lam{\ell\sigma'}{k\,(\lookup{\sigma'}\ell)\,\sigma'}))}\\
\SBB[E]{e_1:=e_2}\rho k &\definedas&
\SBB[E]{e_1}\rho{("check\hyphen loc"\,(\lam\ell{\SBC[E]{e_2}\rho{(\lam{v\sigma'}{k\,("Null","nil")\,(\update{\sigma'}v\ell)})}}))}.
\)
                                                               
