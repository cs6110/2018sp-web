\lecture{15}
\title{Exceptions and First-Class Continuations}
\date{4 March 2016}
\maketitle

\section{Exceptions}

An exception mechanism allows non-local transfer of control in exceptional situations.  It is typically used to handle abnormal, unexpected, or rarely occurring events.  It can simplify code by allowing programmers to factor out these uncommon cases.  OCaml also uses them for not-found conditions when searching lists and similar data structures, a questionable design decision; Standard ML uses "option" for this purpose.

To add an exception handling mechanism to \FL, we first extend the syntax:
\(
e &::=& \ldots \bnf "raise"\,s\,e \bnf "try"\,e_1\,"handle"\,(s\,x)\,e_2
\)
Informally, the idea is that "handle" provides
a handler $e_2$ to be invoked when the exception named $s$ is encountered
inside the expression $e_1$. To raise an exception, the program
calls $"raise"\,s\,e$, where $s$ is the name of an exception
and $e$ is an expression that will be passed to the handler as its
argument $x$.

Most languages use a dynamic scoping mechanism to find the handler for a given exception.  When an exception is encountered, the language walks up the runtime call stack until a suitable exception handler is found.

\subsection{Exceptions in \FL}

To add support for exceptions to our CPS translation, we add a \emph{handler environment} $h$, which maps exception names to continuations.  We also extend our "lookup" and "update" functions to accommodate handler environments.  Applied to a handler environment, "lookup" returns the continuation bound to a given exception name, and "update" rebinds an exception name to a new continuation.

Now we can add support for exceptions to our translation:
\(
\SBC[E]{"raise"\,s\,e}\rho k h &\definedas& \SBC[E]e\rho{(\lookup hs)}h\\
\SBC[E]{"try"\,e_1\,"handle"\,(s\,x)\,e_2}\rho kh &\definedas& 
\SBC[E]{e_1}\rho k{(\update h{(\lam v{\SBC[E]{e_2}{(\update\rho vx)}kh})}s)}\\
\SBC[E]{\lam xe}\rho kh &\definedas& k\,("tag\hyphen fun"\,(\lam{vk'h'}{\SBC[E]e{(\update\rho vx)}{k'}{h'}}))\\
&=& k\,("tag\hyphen fun"\,(\lam v{\SBC[E]e{(\update\rho vx)}}))\\
\SBC[E]{e_0\,e_1}\rho kh &\definedas&
\SBC[E]{e_0}\rho{("check\hyphen fun"\,(\lam f{\SBC[E]{e_1}\rho{(\lam v{fvkh})}h}))}h
\)
where "tag-fun" tags a function value with its runtime type.

There are some subtle design decisions captured by this translation. For example, note that in "try\ldots handle", $x$ is in scope in $e_2$, but $s$ is not. Thus if $e_2$ attempts to raise exception $s$ in $"try"\,e_1\,"handle"\,(s\,x)\,e_2$, in this translation $e_2$ will not be invoked again. That is, $e_2$ cannot be invoked recursively.

\subsection{Exceptions with Resumption}

The exception mechanism above has the property that raising an exception
terminates execution of the evaluation context. Most modern programming
languages have exceptions with this _termination semantics_. A different
approach to exceptions is to allow execution to continue at the point
where the exception was raised, after the exception handler gets a
chance to repair the damage. This approach is known as exceptions with
_resumption semantics_. In practice it seems to be difficult to use
these mechanisms usefully. The Cedar/Mesa system supported both kinds
of exceptions and found that resumption-style exceptions were almost
never used, and often resulted in bugs when they were.

Operating system interrupts are one place where resumption semantics can
be seen. When a process receives an interrupt, the interrupt handler is
run, and then execution continues at the point in the program where the
interrupt happened.

We can give a translation that captures the semantics of
resumption-style exceptions. We add two constructs to \FL:
\[
 e ::= "interrupt"\,s\,e \bnf "try"\,e_1\,"handle"\,(s\,x)\,e_2
\]
The translation makes the exception-handling environment $h$ a mapping
from exception names to _functions_ rather than to continuations:
\begin{eqnarray*}
\SBC{"interrupt"\,s\,e}\rho kh &=& \SBC{e}\rho{(\lam{v}{(\lookup h s)\,v\,k})}h\\
\SBC{"try"\,e_1\,"handle"\,(s\,x)\,e_2}\rho kh &=& \SBC{e_1}\rho k{(\update h{(\lam{vk'}{\SBC{e_2}\rho{k'}h})}s)}
\end{eqnarray*}
\noindent This translation shows that with resumption semantics,
the exception handler is really a dynamically bound function that is
invoked at the point where the exception happens.

\section{First-Class Continuations}

Some languages expose continuations as first-class values. Examples of
such languages include Scheme and SML/NJ. In the latter, there is
a module that defines a continuation type "$\alpha$ cont" representing a continuation
expecting a value of type $\alpha$. There are two functions for manipulating
continuations:
\begin{itemize}
\item
$"callcc" : (\alpha\,"cont" \to\alpha)\to\alpha$\quad("callcc" $f$) passes the current continuation to the function $f$
\item
$"throw" : \alpha\,"cont" \to \alpha \to \beta$\quad("throw" $k$ $v$) sends the value $v$ to the continuation $k$.
\end{itemize}
The call $("callcc"\,f)$ passes the current continuation corresponding to the
evaluation context of the "callcc" itself to the function $f$ of type $\alpha\,"cont" \to \alpha$.
The current continuation $k$ is of type $\alpha\,"cont"$.
When called with this continuation, $f$ may evaluate to a value of type $\alpha$,
and that is the value of the expression $("callcc"\,f)$ that called it.
However, the continuation $k$ passed to $f$ may be called with a value $v$ of type $\alpha$
by $("throw"\,k\,v)$ with the same effect.
It is up to the evaluation context of the "callcc" to determine which.
Thus $("callcc"\ \lam k3)$ and $("callcc"\ \lam k{"throw"\,k\,3})$ have the same effect.

\subsection{Semantics of First-Class Continuations}

Using the translation approach we introduced earlier, we can easily
describe these mechanisms. Suppose we represent a continuation value
for the continuation $k$ by tagging it with the integer 7. Then we
can translate "callcc" and "throw" as follows:
\begin{eqnarray*}
\SBB{"callcc"\,e}\rho k &=& \SBB{e}\rho(\CHECKFUN\,(\lam{f}{f\,(7,k)\,k})) \\
\SBB{"throw"\,e_1\,e_2}\rho k &=& \SBB{e_1}\rho{(\CHECKCONT\,(\lam{k'}{\SBB{e_2}\rho{k'}}))}
\end{eqnarray*}
The key to the added power is the non-linear use of $k$ in the "callcc" rule.
This allows $k$ to be reused any number of times.

\subsection{Implementing Threads with Continuations}

Once we have first-class continuations, we can use them to implement
all the different control structures we might want. We can even use them
to implement (non-preemptive) threads, as in the following code that explains how
concurrency is handled in languages like OCaml and Concurrent ML:

\begin{code}
\tt
   type thread = unit cont
\mbox{}
   let ready : thread queue = new\_queue (* a mutable FIFO queue *)
   let enqueue t = insert ready t
   let dispatch() = throw (dequeue ready) ()
\mbox{}
   let spawn (f : unit -> unit) : unit =
     callcc (fun k -> (enqueue k; f(); dispatch()))
   let yield() : unit = callcc (fun k -> enqueue k; dispatch())
\end{code}

The interface to threads consists of the functions "spawn" and "yield". The
"spawn" function expects a function "f" containing the work to be done in the
newly spawned thread. The "yield" function causes the current thread to
relinquish control to the next thread on the ready queue. Control also
transfers to a new thread when one thread finishes evaluating. To complete
the implementation of this thread package, we just need a queue
implementation. CML has preemptive threads, in which threads implicitly
yield automatically after a certain amount of time; this 
requires just a little help from the operating system.
