\lecture{29}
\title{Propositions as Types, Continued}
\date{16 April 2014}
\maketitle

\section{A Digression on Heyting Algebra}

There are fewer formulas that are considered intuitionistically valid than classically valid.  The law of double negation ($\neg\neg\phi\to\phi$), the law of excluded middle ($\phi\vee\neg\phi$), and proof by contradiction or reductio ad absurdum are no longer accepted.

Boolean algebra is to classical logic as _Heyting algebra_ is to intuitionistic logic.  A Heyting algebra is an algebraic structure of the same signature as Boolean algebra, but satisfying only those equations that are provable intuitionistically.  Whereas the free Boolean algebra on $n$ generators has $2^{2^n}$ elements, the free Heyting algebra on one generator has infinitely many elements.
\begin{center}
\begin{picture}(0,100)(110,-30)
\multiput(0,0)(20,20)2{\multiput(0,0)(-20,20)2{\circle*{4}}}
\multiput(0,0)(20,20)2{\line(-1,1){20}}
\multiput(0,0)(-20,20)2{\line(1,1){20}}
\put(0,-5){\makebox(0,0)[t]{$\bot$}}
\put(-25,20){\makebox(0,0)[r]{$P$}}
\put(25,20){\makebox(0,0)[l]{$\neg P$}}
\put(0,45){\makebox(0,0)[b]{$\top$}}
\put(0,-30){\makebox(0,0)[b]{\textsl{Free Boolean algebra on one generator}}}
\end{picture}
\begin{picture}(0,230)(-110,-30)
\multiput(0,0)(-20,20)3{\circle*{4}}
\multiput(20,20)(0,40)3{\multiput(0,0)(-20,20)4{\circle*{4}}}
\multiput(20,140)(-20,20)2{\circle*{4}}
\put(0,0){\line(-1,1){40}}
\multiput(20,20)(0,40)3{\line(-1,1){60}}
\put(0,0){\line(1,1){20}}
\multiput(-20,20)(-20,100)2{\line(1,1){40}}
\multiput(-40,40)(0,40)2{\line(1,1){60}}
\put(20,140){\line(-1,1){20}}
\put(0,-5){\makebox(0,0)[t]{$\bot$}}
\put(-23,17){\makebox(0,0)[tr]{$P$}}
\put(25,20){\makebox(0,0)[l]{$\neg P$}}
\put(-45,40){\makebox(0,0)[r]{$\neg\neg P$}}
\put(7,40){\makebox(0,0)[l]{$P\vee\neg P$}}
\put(25,60){\makebox(0,0)[l]{$\neg\neg P\to P$}}
\put(-27,60){\makebox(0,0)[r]{$\neg P\vee\neg\neg P$}}
\put(-10,195){\makebox(0,0){$\top$}}
\put(-10,180){\makebox(0,0){$\vdots$}}
\put(0,-30){\makebox(0,0)[b]{\textsl{Free Heyting algebra on one generator}}}
\end{picture}
\end{center}
The picture on the right is sometimes called the _Rieger--Nishimura ladder_.

\section{Uninhabited Types}

Since the proposition $\bot$ is not provable, it follows that if it
corresponds to a type 0, that type must be uninhabited:
there is no term with that type.  Of course, $\bot$ is not the only
uninhabited type; for example, the type $\fa\alpha\alpha$ also
corresponds to logical falsity and is uninhabited as well.

Note that we can produce terms with these types if we have
recursive functions, as in the following term with type 0:
\[
("rec"~f : "int"\to 0. \lam{\type x{int}}{f(x)})\,42
\]
However, the typing rule for recursive functions corresponds to
a logic rule that makes the logic inconsistent: it assumes what it
wants to prove!
\begin{center}
\AxiomC{$\judge{\Gamma,\,\type{y}{\tau\to\tau'},\,\type x\tau}{e}{\tau'}$}
\UnaryInfC{$\Gjudge{("rec"~y\ty\tau\to\tau'.\lam{x\ty \tau}{e})}{\tau\to\tau'}$}
\DisplayProof
\qquad
\AxiomC{$\Gamma,\,\phi\Rightarrow\phi',\,\phi \force \phi'$}
\UnaryInfC{$\Gamma \force \phi \Rightarrow \phi'$}
\DisplayProof
\end{center}
Thus, we can think of 0 as the type of a term that does not actually
return to its surrounding context.

\section{Continuations and Negation}

What is the significance of negation? We know that logically $\neg\phi$
is equivalent to $\phi\Rightarrow\bot$, which suggests that we can think of $\neg\phi$
as corresponding to a function $\tau\to 0$.  We have seen functions
that accept a type and do not return a value before: continuations
have that behavior. If $\phi$ corresponds to $\tau$, a reasonable
interpretation of $\neg\phi$ is as a continuation expecting a $\tau$. Negation
corresponds to turning outputs into inputs.

As we saw above with currying and uncurrying, meaning-preserving program
transformations can have interesting logical interpretations. What about
conversion to continuation-passing style? We represent a continuation
$k$ expecting a value of type $\tau$ as a function with type $\tau\to 0$.

We can then define CPS conversion as a type-preserving translation
$\SB{\Gjudge e\tau}$.  Here we include the entire type derivation
$\Gjudge e\tau$ inside the $\SB{\cdot}$ because types are not unique and
the translation depends on the typing.  The translation is type-preserving in the sense that a well-typed
source term $(\Gjudge e\tau)$ translates to a well-typed target term:
\[
\judge{\SB[G]{\Gamma}}{\SB{\Gjudge e\tau}}{\SB[T]\tau}.
\]
The translation of the typing
context $\SB[G]{\Gamma}$ simply translates all the contained variables:
\[
\SB[G]{x_1\ty\tau_1,\dots,x_n\ty\tau_n} = x_1\ty\SB[T]{\tau_1},\dots,x_n\ty\SB[T]{\tau_n}.
\]
The soundness of the translation can be seen by induction on the typing derivation. 

\begin{eqnarray*}
\SB{\judge{\Gamma,\,\type x\tau}x\tau} &=& \lam{\type k{\SB[T]{\tau}\to 0}}{k\,x} \\
\SB{\Gjudge{(\lam{\type x\tau}{e})}{\tau\to\tau'}} &=&
  \lam{\type k{\SB[T]{\tau\to\tau'}\to 0}}{k\,(\lam{\type{k'}{\SB[T]{\tau'}\to 0}}{\lam{\type x{\SB[T]\tau}}
  {\SBA{\judge{\Gamma,\,\type x\tau}{e}{\tau'}}k'})}} \\
\SB{\Gjudge{(e_0\,e_1)}{\tau'}} &=&
\lam{\type k{\SB[T]{\tau'}\to 0}}{
  \SB{\Gjudge{e_0}{\tau\to\tau'}}\,(\lam{\type f{\SB[T]{\tau\to\tau'}}}
  {\SB{\Gjudge{e_1}{\tau}}\,(\lam{\type v{\SB[T]\tau}}{f\,k\,v})})}
\end{eqnarray*}

To make this type-check, we define the type translation $\SB[T]{\cdot}$ as follows:
\(
\SB[T]{B} &=& B \\
\SB[T]{\tau\to\tau'} &=& (\SB[T]{\tau'}\to 0)\to(\SB[T]{\tau}\to 0)
\)
Note that the logical interpretation of the translation of a function
type corresponds to the use of the contrapositive:
$(\phi\Rightarrow\psi)\ \Rightarrow\ (\neg\psi\Rightarrow\neg\phi)$.

By induction on the typing derivation, we can see that CPS conversion
converts a source term of type $\tau$ into a target term of type $(\Tr
T{\tau}\to 0)\to 0$. Since programs correspond to proofs, CPS conversion shows
how to convert a proof of proposition $\phi$ into a proof of proposition
$\neg\neg\phi$. In other words, CPS conversion proves the admissibility in
constructive logic of the rule for introducing double negation:
\begin{center}
\AxiomC{$\phi$}
\UnaryInfC{$\neg\neg\phi$}
\DisplayProof
\end{center}
However, we are unable to invert CPS translation, and similarly we
are unable (constructively) to _remove_ double negation.

\section{Extracting Computational Content}

Many automated deduction systems, such as NuPrl and Coq, are based on constructive logic.  Automatic programming was a significant research direction that motivated the development of these systems.  The idea was that a constructive proof of the existence of a function would automatically yield a program to compute it: the statement asserting the existence of the function is a type, and a constructive proof yields a $\lambda$-term inhabiting that type.  For example, to obtain a program computing square roots, one merely has to give a constructive proof of the statement $\forall x\geq 0\ \exists y\ y^2=x$.

\section{Other Directions}

If second-order constructive predicate logic corresponds to System F, do
other logics correspond to new kinds of programming language features?
This has been an avenue of fruitful exploration over the last couple
of decades, with programming-language researchers deriving insights
from classical logic, higher-order, and linear logics that help guide
the design of useful language features.

For example, _linear logic_ is a logic that keeps track of resources.  One may only use an assumption in the application of a rule once; the assumption is consumed and may not be reused.  This corresponds to functions that consume their arguments, and hence is a possible model for systems with bounded resources.
