\lecture{19}
\title{Typed $\lambda$-Calculus}
\date{6 April 2016}

\maketitle

\section{Introduction}

_Type checking_ is a lightweight technique for proving
simple properties of programs. Unlike theorem-proving
techniques based on axiomatic semantics,
type checking usually cannot determine if a program will
produce the correct output. Instead, it is a way to test
whether a program is _well-formed_, with the idea that a
well-formed program satisfies certain desirable
properties. The traditional application of type checking
is to show that a well-formed program cannot get stuck; that is,
that a type-correct program will
never reach a non-final configuration in its operational
semantics from which its behavior is undefined. This is a
weak notion of program correctness, but nevertheless very
useful in practice for catching bugs.

Type systems are a powerful technique. In the past couple
of decades, researchers have discovered how to use type systems
for a variety of different verification tasks.

\section{$\lambda^\to$}

We have already seen some typed languages in class this semester.
For example, OCaml and the metalanguage used in class for denotational
semantics are both typed.

To explore the idea of type checking itself, we introduce
$\lambda^\to$, a typed variant of the $\lambda$-calculus in which
we assign types to certain $\lambda$-terms according to some typing rules.
A $\lambda$-term is considered to be well-formed if a type can
be derived for it using the rules. We will give operational and denotational
semantics for this language. Along the way, we will discover
some interesting properties that give insight about typing in more
complex languages.

\section{Syntax}

The syntax of $\lambda^\to$ is similar to that of untyped $\lambda$-calculus, with some notable differences. There are two kinds of inductively-defined expressions, _terms_ and _types_:
\[
\begin{array}{lrcl}
\mbox{terms} & e &::=& n \bnf "true" \bnf "false" \bnf "null" \bnf x \bnf e_1\,e_2 \bnf \lam{\type x\tau}e\\
\mbox{types} & \tau &::=& "int" \bnf "bool" \bnf "unit" \bnf \tau _1 \to \tau _2
\end{array}
\]
One difference is that the natural numbers, Boolean constants, and "null" are taken to be primitive symbols and not defined as $\lambda$-terms. For this reason, we no longer need to distinguish between the syntactic objects $\overline n$ and $\TRUE$ and their semantic counterparts $n$ and $\true$, so we might as well just identify them.
Another difference is that a $\lambda$-abstraction explicitly mentions the type of its argument. Thus
$\lam{\type x\tau}e$ represents a function that takes an input value of type $\tau$ and evaluates $e$.

A _value_ is either a number, a Boolean constant, "null", or a closed abstraction $\lam{\type x\tau}e$. The set of values is denoted \Val. The set of types is denoted \Type.

A \emph{type} represents a collection of related values. The types "int", "bool", and "unit" represent integers, Booleans, and "null", respectively. The type $\tau_1\to\tau_2$ represents functions that take inputs of type $\tau_1$ and produce outputs of type $\tau_2$.

There are some _typing rules_, given below, that can be used to associate a type
with a term. The rules are used to derive _type judgments_ of the form 
$\judge{\Gamma}e\tau$, which means intuitively that under the assumptions
$\Gamma$, the term $e$ has type $\tau$.
The assumptions $\Gamma$ specify types for the free variables of $e$.
We write $\judge{}e\tau$ when $e$ is a closed term and $\Gamma$ is empty.

For example, every number has type "int", thus $\judge{}3{"int"}$.
The type "unit" is the type of the value "null", and nothing else
has this type. The function $\TRUE\sub{int} =
\lam{\type x{"int"}}{\lam{\type y{"int"}}x}$ has the type $"int"
\to "int" \to "int"$.
By convention, the type constructor $\to$ associates to the right, so
$"int" \to "int" \to "int"$
is the same as
$"int" \to ("int" \to "int")$.
Thus we can write
\begin{eqnarray*}
\TRUE\sub{int} &\definedas& (\lam{\type x{"int"}}{\lam{\type y{"int"}}x}) : "int" \to "int" \to "int".
\end{eqnarray*}
Not all $\lambda$-terms can be typed, for instance $\lam{\type x{"int"}}{xx}$ or $"true"\,3$. These expressions are considered ill-formed and nonsensical.

Right now, we cannot do anything interesting with integers or Booleans, because we do not have any operations on them. Later on we will be adding other typed constants such as $\type{"plus"}{"int"\to"int"\to"int"}$ and $\type{"equal"}{"int"\to"int"\to"bool"}$, but for now they are just there to set the stage.

\section{Small-Step Operational Semantics and Type Correctness}

The small-step CBV operational semantics of $\lambda^\to$ is the same as that of the untyped $\lambda$-calculus. The presence of types does not alter the evaluation rules for expressions. 
\begin{align*}
E\ &::=\ E\,e \bnf v\,E \bnf \hole & (\lam{\type x\tau}e)\,v\ &\to\ \subst evx
\end{align*}
We will eventually show that these reduction rules preserve typing
in the sense that if $e$ has type $\tau$ and $e\stackrel*\to e'$,
then $e'$ also has type $\tau$.
Thus ``well-typedness'' of programs is invariant under the evaluation rules of the language.
This property is known as \emph{type preservation} or \emph{subject reduction}.
Another important property is \emph{progress}, which says that a well-typed program is never stuck;
that is, it is either a value or a further transition is possible.
These two properties together imply that no well-typed
term can ever become stuck. Thus the typing rules can be used
in place of runtime type checking to ensure strong typing.

It is natural to ask what a type-incorrect term
might look like and how it could get stuck.
Recall our function definition for
$\TRUE\sub{int}$ above, and consider the following additional
definition:
\begin{eqnarray*}
\IF\sub{int} &\definedas& \lam{\type t{"int" \to "int" \to "int"}}{\lam{\type a{"int"}}{\lam{\type b{"int"}}{t\,a\,b}}}.
\end{eqnarray*}
Clearly, $\IF\sub{int}\,\TRUE\sub{int}\,2\,3$ evaluates to 2.
However, $\IF\sub{int}\,"true"\,2\,3\to "true"\,2\,3$, and this
expression is meaningless, since "true" is not a function and cannot
be applied to anything. Therefore, the program would be stuck at this point.

\section{Typing Rules}

The typing rules will determine which terms are well-formed $\lambda^\to$ programs.
They are a set of rules that allow the derivation of _type judgments_ of the form $\Gjudge e\tau$.
Here $\Gamma$ is a _type environment_, a partial map from variables to types used to determine the types of the free variables in $e$. The domain of $\Gamma$ as a partial function $\Var\rightharpoonup\Type$ is
denoted $\dom\Gamma$.

The environment $\rebind\Gamma\tau x$ is obtained by rebinding $x$ to $\tau$ (or creating the binding anew if $x\not\in\dom\Gamma$):
\(
\rebind\Gamma\tau x(y) &\definedas&
\begin{cases}
\Gamma(y), & \mbox{if $y\neq x$ and $y\in\dom\Gamma$,}\\
\tau, & \mbox{if $y=x$,}\\
\mbox{undefined,} & \mbox{otherwise.}
\end{cases}
\)
The notation $\Gamma,\,\type x\tau$ is synonymous with $\rebind\Gamma\tau x$. The former is standard notation in the literature. Also, one often sees $\type x\tau\in\Gamma$, which means just $\Gamma(x)=\tau$.

We also write $\Gjudge e\tau$ as a metaexpression to mean that the type judgment $\Gjudge e\tau$ is derivable from the typing rules. The environment $\emptyset$ is the empty environment, and the judgment $\judge{}e\tau$ is short for $\judge\emptyset e\tau$.

Here are the typing rules:
\[
\begin{array}{c@{\hspace{1cm}}c@{\hspace{1cm}}c@{\hspace{1cm}}c@{\hspace{1cm}}c}
\Gjudge n{"int"} & \Gjudge{"true"}{"bool"} & \Gjudge{"false"}{"bool"} & \Gjudge{"null"}{"unit"} & \judge{\Gamma,\,\type x\tau}x\tau
\end{array}
\]
\begin{center}
\begin{tabular}{c@{\hspace{1cm}}c}
\infer{\Gjudge{e_0\,e_1}{\tau}}{\Gjudge{e_0}{\sigma\to\tau} & \Gjudge{e_1}\sigma}
& \infer{\Gjudge{(\lam{\type x\sigma}e)}{\sigma\to\tau}}{\judge{\Gamma,\,\type x\sigma}e{\tau}}
\end{tabular}
\end{center}
Let us explain these rules in more detail.
\begin{itemize}
\item
The first four rules just say that all the base values have their corresponding base types.
\item
For a variable $x$, $\Gjudge x\tau$ holds if the binding $\type x\tau$ appears in the type environment $\Gamma$; that is, if $\Gamma(x)=\tau$.
\item
An application expression $e_0\,e_1$ represents the result of applying the function represented by $e_0$ to the argument represented by $e_1$. For this to have type $\tau$, $e_0$ must be a function of type $\sigma\to\tau$ for some $\sigma$, and its argument $e_1$ must have type $\sigma$. This is captured in the typing rule for $e_0\,e_1$.
\item
Finally, a $\lambda$-abstraction $\lam{\type x\sigma}e$ is supposed to represent a function. The type of the input should match the annotation in the term, thus the type of the function must be $\sigma\to\tau$ for some $\tau$. The type $\tau$ of the result is the type of the body under the extra type assumption $\type x\sigma$. This idea is captured in the typing rule for $\lambda$-abstractions.
\end{itemize}

Every well-typed $\lambda^\to$ term has a proof tree consisting of applications of the typing rules to derive a type for the term. We can type-check a term by constructing this proof tree. For example, consider the program $(\lam{\type x{"int"}}{\lam{\type y{"bool"}}x})\,2\,"true"$, which evaluates to 2. Since $\judge{}2{"int"}$, we expect $\judge{}{((\lam{\type x{"int"}}{\lam{\type y{"bool"}}x})\,2\,"true")}{"int"}$ as well. Here is a proof of that fact:
\begin{center}
\begin{tabular}{c}
\infer{\judge{}{((\lam{\type x{"int"}}{\lam{\type y{"bool"}}x})\,2\,"true")}{"int"}}
   {\infer{\judge{}{((\lam{\type x{"int"}}{\lam{\type y{"bool"}}x})\,2)}{"bool"\to"int"}}
       {\infer{\judge{}{(\lam{\type x{"int"}}{\lam{\type y{"bool"}}x})}{"int"\to"bool"\to"int"}}
          {\infer{\judge{\type x{"int"}}{(\lam{\type y{"bool"}}x)}{"bool"\to"int"}}
              {\judge{\type x{"int"},\,\type y{"bool"}}{x}{"int"}}}
      & {\judge{}2{"int"}}}
  & {\judge{}{"true"}{"bool"}}}
\end{tabular}
\end{center}

An automated type checker can effectively construct proof trees like this in order to test whether a program is type-correct.

Note that types, if they exist, are unique. That is, if $\Gjudge e\tau$ and $\Gjudge e{\tau'}$, then $\tau=\tau'$. This can be proved easily by structural induction on $e$, using the fact that there is exactly one typing rule that applies in each case, depending on the form of $e$.

\section{Expressive Power}

By now you may be wondering if we have lost any of the expressive power
of $\lambda$-calculus by introducing types. The answer to this
question is a resounding _yes_. For example, we can no longer compose
arbitrary functions, since they may have mismatched types.

More importantly, we have lost the ability to write loops. Recall the paradoxical combinator
\begin{eqnarray*}
\Omega &\definedas& (\lam x{xx})\,(\lam x{xx}).
\end{eqnarray*}
Let us show that any attempt to derive a typing for the term $\lam{\type x\sigma}{xx}$ must fail:
\begin{center}
\begin{tabular}{c}
\infer{\Gjudge{(\lam{\type x\sigma}{xx})}{\sigma\to\tau}} {
  \infer {\judge{\Gamma,\,\type x\sigma}{xx}\tau} {
    \judge{\Gamma,\,\type x\sigma}x{\sigma\to\tau} &
    \judge{\Gamma,\,\type x\sigma}x\sigma
  }
}
\end{tabular}
\end{center}
We see that we must have both $\judge{\Gamma,\,\type x\sigma}x{\sigma\to\tau}$ and
$\judge{\Gamma,\,\type x\sigma}x\sigma$. However, since types are unique, this is impossible; we cannot
have $\sigma=\sigma\to\tau$, since no type expression can be a subexpression
of itself. We conclude that the term $\lam{\type x\sigma}{xx}$ cannot be typed.

In fact, we will see later
that we cannot write down _any_ nonterminating program in $\lambda^\to$.
This will turn out be true from an operational perspective as well.
In later lectures we will show how to extend the type
system to allow loops and nonterminating programs.

\section{Denotational Semantics}

Before we can give the denotational semantics for $\lambda^\to$,
we need to define a new meaning function $\SB[T]\cdot$ that maps each
type to a domain associated with that type. For this type system,
the definition of $\SB[T]\cdot$ is straightforward:
\begin{align*}
\SB[T]{"int"}\ &\definedas\ \integers &
\SB[T]{"bool"}\ &\definedas\ \Two &
\SB[T]{"unit"}\ &\definedas\ \{"null"\} &
\SB[T]{\sigma\to\tau}\ &\definedas\ \SB[T]{\sigma}\to\SB[T]{\tau}.
\end{align*}
In the last equation, note that the $\to$ on the left-hand side is just a symbol
in the language of types, a syntactic object, whereas the $\to$ on the
right-hand side is a semantic object, namely the operator that constructs
the space of functions between a given domain and range.
For now, these domains need not have any ordering properties; they are just
sets. So we have $\Tr T\cdot:\Type\to\Set$.

For any closed term $e$, if $\judge{}e\tau$, then we expect the denotation of $e$ to be an
element of $\SB[T]\tau$. More generally, for a term $e$ possibly containing free variables,
if there is a type environment $\Gamma$ and a value environment
$\rho$ such that $\rho$ and $\Gamma$ are defined on all the free variables
of $e$ and $\rho(x)\in\SB[T]{\Gamma(x)}$
for all $x\in\FV e$, and if $\Gjudge e\tau$, then we expect the denotation of $e$ in environment
$\rho$ to be an element of $\SB[T]\tau$.

We say that the value environment $\rho$ _satisfies_ a type
environment $\Gamma$ and write $\rho\sat\Gamma$ if
$\dom\Gamma\subseteq\dom\rho$ and for every $x\in\dom\Gamma$,
$\rho(x)\in\SB[T]{\Gamma(x)}$.

%This kind of semantics---where we do not assign any meaning
%to ill-formed terms---is known as a _Church-style semantics_.
%The alternative is _Curry-style
%semantics_, in which we give a meaning even to programs that are
%not well-typed.
%Our operational semantics, for example,
%talks about how to evaluate even ill-typed terms.

We are now ready to give the denotational semantics
for typed $\lambda$-terms.
We only define the meaning function for well-typed expressions.
The following function is
defined only for $e$, $\Gamma$, and $\rho$ such that
$\rho\sat\Gamma$ and $e$ is well-typed under $\Gamma$;
that is, $\Gjudge e\tau$ for some type $\tau$.
\(
\SBB[C]{n}\Gamma\rho &\definedas& n\\
\SBB[C]{\TRUE}\Gamma\rho &\definedas& \TRUE\\
\SBB[C]{\FALSE}\Gamma\rho &\definedas& \FALSE\\
\SBB[C]{\NULL}\Gamma\rho &\definedas& "null"\\
\SBB[C]{x}\Gamma\rho &\definedas& \rho(x),\quad x\in\dom\Gamma\\
\SBB[C]{e_0\,e_1}\Gamma\rho &\definedas& (\SBB[C]{e_0}\Gamma\rho)\,(\SBB[C]{e_1}\Gamma\rho)\\
\SBB[C]{\lam{\type x\tau}e}\Gamma\rho &\definedas& \lm v{\SB[T]{\tau}}{\SBB[C]e{\rebind\Gamma\tau x}{\rebind\rho vx}}
\)

\section{Soundness}

It is possible to show that $\SB[C]\cdot$ satisfies
the following soundness condition: for all $\rho$, $\Gamma$, $e$, and $\tau$,
\begin{eqnarray*}
\rho\sat\Gamma\ \wedge\ \Gjudge e\tau &\Rightarrow& \SBB[C]{e}\Gamma\rho \in \SB[T]\tau.
\end{eqnarray*}
The proof is by induction on the structure of $e$.
The only interesting step is the case of a $\lambda$-term, which requires the observation
\(
\rho\sat\Gamma\ \wedge\ v\in\SB[T]\tau
&\Rightarrow& \rebind\rho vx \sat \rebind\Gamma\tau x.
\)

Note that $\bot$ does not appear anywhere in this
semantics. We did not need it because we never took a fixpoint.
We can conclude that all well-typed $\lambda$-terms represent total functions.

Of course, we will also want to see that the operational semantics
is adequate with respect to this model to ensure that our evaluation
relation actually produces the values of the correct type that
the denotational model advertises are there.
For example, for a closed term $e$ such that $\judge{}e{"int"}$, 
the adequacy condition would say that
\(
e \stackrel*\to n &\Leftrightarrow& \SBB[C]e\emptyset\emptyset = n.
\)
