\lecture{27}
\title{Existential Types}
\date{29 April 2016}

\maketitle

\section {Modeling Objects with Recursive Types}

We have been exploring language semantics in a largely reductionist way,
by breaking apart complex mechanisms into simpler components. Objects
are an example of a complex mechanism that we had hoped our studies would
shed some light on. However, if we try to encode objects in terms of
the simpler constructs we have seen so far, we see that there is something missing.

Consider the following Java implementation of integer sets as binary search trees:
\begin{small}
\begin{alltt}
   class Intset \{
      Intset union(Intset s) \{ ... \}
      boolean contains(int n) \{
         if (n < value) return (left != null) && left.contains(n);
         else if (n > value) return (right != null) && right.contains(n);
         else return n == value;
      \}
      int value;
      Intset left, right;
   \}
\end{alltt}
\end{small}
One of the challenges of modeling objects is that they can refer to
themselves. For example, the code of the "contains" method is implicitly
recursive with respect to the object "this", because the values "left"
and "right" are actually "this.left" and "this.right".

With recursive types and records we can approximate this in the typed $\lambda$-calculus.
First, there is a type "Intset" being declared:

\[
%"Intset"\ =\ \mu S.(\{ "union" : S \rightarrow S,\,"contains" : "int" \rightarrow "bool",\,"value" : "int",\,"left" : S,\,"right" : S \} + "unit")
"Intset"\ =\ \mu S.\{ "union" : S \rightarrow S,\,"contains" : "int" \rightarrow "bool",\,"value" : "int",\,"left" : S,\,"right" : S \}
\]

We can construct ``objects'' of this type, assuming we can take a
fixpoint over objects (which is possible as long as only methods
can refer to the fixpoint):

%let s = fold\mth{_{\mathtt{Intset}}} inl (rec this: \{ union : Intset \mth{\rightarrow} Intset, ... \}. // the unfolding of Intset
%    \{ union = \fn{s'} : Intset. \ldots
%      contains = \fn{n} : int. if n = this.value then true
%          else if m \lt this.value then case this.left of
%                  \fn{u}:"unit". false
%                  \fn{s'}:Intset. ((unfold s').contains) n
%                else ...
%    \}
\begin{small}
\begin{code}
\tt
   let s = fold$_{Intset}$ (rec this: \{ union : Intset \mth{\rightarrow} Intset, ... \}. // the unfolding of Intset
   \{
      union = $\lambda${s'} : Intset. \ldots
      contains = $\lambda${n} : int.
         if m < this.value then case this.left of
            $\lambda${s'}:Intset.((unfold s').contains) n
         else if m > this.value then case this.right of
            $\lambda${s'}:Intset.((unfold s').contains) n
         else n = this.value
   \}
\end{code}
\end{small}

This whole expression has type "Intset" and will behave
mostly like an object. There are a couple of ways in which
this falls short of what Java objects provide: first, there
is no inheritance, and we will have trouble extending this code
to support inheritance. Second, the internals of the class
are fully exposed to any other objects or functions that might
use it. We need some way of providing a restricted interface
to our objects and classes. It is this second problem we
will talk about now.

\section {Encapsulation}

While we can encode objects currently, we are missing one of the key
concepts of object-oriented programming: _data abstraction_, which in the
object-oriented programming world sometimes is called _information hiding_ or _encapsulation_.
This is a feature in which the type system hides internals of objects, enforcing an
abstraction barrier between the implementer and the clients of the
class. This abstraction barrier helps keep different parts of the system
loosely coupled so they can be updated and maintained without close
coordination.

Data abstraction is offered in its purest form by _existential types_.
The idea is that we can hide part of a type $\tau$ and
replace it with a type variable $\alpha$. We write $\exists \alpha.\tau$
to represent this type, where $\alpha$ may be mentioned inside
$\tau$. But because this type does not say what $\alpha$ is, no
code receiving a value of this type can make use of
knowledge of the hidden part of this type.

For example, in the "Intset" example we would write:

\begin{code}
\tt
   $\exists\alpha$.\,$\mu{S}$. \{
       union: $S\to{S}$
       contains: int $\to$ bool
       private: $\alpha$
   \}
\end{code}

We can think of values of this type as being a kind of pair consisting of a
type and a value. That is, the pair $[\tau,v] : \exists \alpha .
\sigma$ where $v : \subst{\sigma}{\tau}{\alpha}$.  To
manipulate these values, we introduce two new
operators, ``pack'' (the introduction form) and ``unpack''
(the elimination form).

These two forms look, and typecheck, as follows:
%
%\[
%\Rule{\Delta ; \Gamma \force  \subst{e}{\tau}{\alpha} :\subst{\sigma}{\tau}{\alpha} \quad \Delta  \force  \exists\alpha.\sigma :: "type"}
%{\Delta ; \Gamma \force  \pack{\exists \alpha.\sigma}{[\tau,e]}:\exists \alpha.\sigma }
%\]
%
%\[
%\Rule{\Delta ;\Gamma\force e:\exists\alpha.\sigma \quad \Delta ,\alpha\dty"type"; \Gamma, x\ty\sigma \force  e':\tau' \quad \Delta  \force  \tau'::"type" \quad \alpha \notin \Delta }
%{\Delta ; \Gamma \force  \unpack{e}{[\alpha,x]}{e'}:\tau'}
%\]
%
\begin{gather*}
\AxiomC{$\judge{\Delta;\Gamma}{\subst e\tau\alpha}{\subst\sigma\tau\alpha}$}
\AxiomC{$\judge\Delta{\exists\alpha.\sigma}{"type"}$}
\BinaryInfC{$\judge{\Delta;\Gamma}{\pack{\exists\alpha.\sigma}{[\tau,e]}}{\exists\alpha.\sigma}$}
\DisplayProof
\\[1ex]
\AxiomC{$\judge{\Delta;\Gamma}e{\exists\alpha.\sigma}$}
\AxiomC{$\judge{\Delta,\type\alpha{"type"};\Gamma,\type x\sigma}{e'}{\tau'}$}
\AxiomC{$\judge\Delta{\tau'}{"type"}$}
\RightLabel{($\alpha \notin \Delta$)}
\TernaryInfC{$\judge{\Delta;\Gamma}{\unpack{e}{[\alpha,x]}{e'}}{\tau'}$}
\DisplayProof
\end{gather*}
Just as in the case of polymorphism, we had to add the context $\Delta$ in order to make sure that no types refer to unbound type variables.

We need a reduction that unpacks an existentially quantified term:
\[
\unpack{\pack{\exists\alpha.\sigma}{[\tau,v]}}{[\alpha,x]}{e}\ \to\ e \{\tau/\alpha, v/x\}
\]
There are also additional evaluation contexts:
\[
%  E\ \ ::=\ \ \ldots \bnf \pack{}{[\tau,E]} \bnf \unpack{E}{[\alpha,x]}{e}
E\ ::=\ \ldots \bnf \pack{}{[\tau,E]} \bnf \unpack{E}{[\alpha,x]}{e}
\]
Here is a simple example illustrating that we can pack different types
into an implementation of a value without the client being able to tell:
\[
\begin{array}{l}
"let"~p_1 = \pack{\exists\alpha.\alpha*(\alpha\to"bool")}{["int",
(5, \lam{\type n{"int"}}{n=1})]}~"in" \\
\qquad \unpack{p_1}{[\alpha,x]}{(("right"~x)~("left"~x))}
\\ \\
"let"~p_2 = \pack{\exists\alpha.\alpha * (\alpha \to "bool")}{
["bool", (\true, \lam{b\ty"bool"}{\neg b})]}~"in" \\
\qquad \unpack{p_2}{[\alpha,x]}{(("right"~x)~("left"~x))}
\end{array}
\]

\section{Existential Types and Constructive Logic}

The existential types get their names partly because they correspond to inference rules of constructive logic involving the $\exists$ quantifier:

\textit{Typing}:
\begin{gather*}
\AxiomC{$\judge{\Delta;\Gamma}{\subst e\tau\alpha}{\subst\sigma\tau\alpha}$}
\AxiomC{$\judge\Delta{\exists\alpha.\sigma}{"type"}$}
\BinaryInfC{$\judge{\Delta;\Gamma}{\pack{\exists\alpha.\sigma}{[\tau,e]}}{\exists\alpha.\sigma}$}
\DisplayProof
\\[1ex]
\AxiomC{$\judge{\Delta;\Gamma}e{\exists\alpha.\sigma}$}
\AxiomC{$\judge{\Delta,\type\alpha{"type"};\Gamma,\type x\sigma}{e'}{\tau'}$}
\AxiomC{$\judge\Delta{\tau'}{"type"}$}
\RightLabel{($\alpha \notin \Delta$)}
\TernaryInfC{$\judge{\Delta;\Gamma}{\unpack{e}{[\alpha,x]}{e'}}{\tau'}$}
\DisplayProof
\end{gather*}

%\[
%\Rule{\Delta ; \Gamma \force \subst{e}{\tau}{\alpha} : \subst{\sigma}{\tau}{\alpha} \quad \Delta  \force  \exists \alpha.\sigma}
%     {\Delta ; \Gamma \force \pack{\exists\alpha.\sigma}{[\tau,e]}:\exists\alpha.\sigma}
%\]
%\[
%\Rule{\Delta ;\Gamma \force  e:\exists\alpha.\sigma \quad \Delta ,\alpha\dty"type"; \Gamma, x\ty\sigma \force  e':\tau' \quad \Delta  \force  \tau'::"type" \quad \alpha\notin \Delta }
%{\Delta ;\Gamma \force  \unpack{e}{[\alpha,x]}{e'} : {\tau'}}
%\]

\textit{Constructive Logic}:
\begin{align*}
&
\AxiomC{$\ujudge\Gamma{\subst\phi AX}$}
\AxiomC{$\ujudge\Gamma{\type A{"Prop"}}$}
\BinaryInfC{$\ujudge\Gamma{\exists X.\phi}$}
\DisplayProof
&&
\AxiomC{$\ujudge\Gamma{\exists X.\phi}$}
\AxiomC{$\ujudge{\Gamma,\type X{"Prop"},\phi}{\phi'}$}
\RightLabel{($X\notin FV(\phi')$)}
\BinaryInfC{$\ujudge\Gamma{\phi'}$}
\DisplayProof
\end{align*}
%\[
%\Rule{\Gamma \force  \subst{\phi }{A}{X} \quad \Gamma \force  A : "Prop"}{\Gamma \force  \exists X.\phi }
%\]
%\[
%\Rule{\Gamma \force  \exists X.\phi  \quad \Gamma, X\ty"Prop", \phi  \force  \phi ' \quad X \notin FV(\phi ')}{\Gamma \force  \phi '}
%\]

\section{Existentials and Modules in ML}

There is a rough correspondence between existential types and the ML
module mechanism.  For example, an ML signature "Rational" defined as:
\begin{small}
\begin{code}
\tt
   module type Rational =
   sig
     type t
     val plus: t $\to$ t $\to$ t
     ...
   end
\end{code}
\end{small}
corresponds to the existential type
$\exists\alpha.\{plus\ty \alpha\to\alpha\to\alpha, \dots\}$. An ML module
that implements this signature is similar to an extensional value:
\begin{small}
\begin{code}
\tt
   struct
     type t = int * int
     let plus x y = \dots
     ...
   end
\end{code}
\end{small}
corresponds to
$["int"*"int", \{plus =
\lam{x\ty "int"*"int"}{\lam{y\ty"int"*"int"}{\dots}},~\dots\}]_{\exists\alpha.\{plus: \alpha\to\alpha\to\alpha, \dots\}}
$.

Unpacking is similar to the "open" operation on modules.

\section{Strong Existentials}

So far the existential values we have seen are \emph{weak} in the sense
that the values of the abstract type $\alpha$ cannot really escape the
module; they can exist only within an unpack term. This means we cannot
write code corresponding to this ML code:

\begin{small}
\begin{code}
\tt
   let x : Rational.t = Rational.zero in
      Rational.plus(x,x)
\end{code}
\end{small}

To get access to several modules represented as existentials, it will
be necessary to unpack them all at once at the top of the program, to
create a scope in which the abstract types can be mentioned.

The idea of _strong existentials_ is to allow the hidden type to be
mentioned outside. We extend the type language with new _dependent
module types_ with the syntax $e.\alpha$:
\[
\tau ::= \dots \bnf \exists\alpha.\tau \bnf e.\alpha\ \text{($e$ is pure)}
\]
What makes the type $e.\alpha$ a _dependent type_ is that it is a type that
mentions a term, something we have not seen before. The meaning of the
type depends on something that is not necessarily known until run
time. In general we will want to place some restrictions on what terms
can be used in this position, to ensure soundness and to make type
checking tractable. Here we use the description ``pure'' to capture
these restrictions, though there is a whole spectrum of choices about what terms can
be permitted, involving different tradeoffs in expressive power and
tractability.

Certainly we do not want $e$ to be something that has side effects.
A simple choice is that $e$ must be a variable name $x$. A more
complicated choice is to allow record selector expressions of the form
$x.y.z$. Some limited use of function application is the next step up,
bringing us to roughly the expressive power of the SML and OCaml
module systems, with their nested modules and functors.

In any case, we can now use dependent module types to express the typing rule for unpack:
\begin{gather*}
\AxiomC{$\judge{\Delta;\Gamma}e{\exists\alpha.\sigma}$}
\AxiomC{$\judge{\Delta,\alpha\dty"type";\Gamma,x\ty \sigma}{e'}{\tau'}$}
\AxiomC{$\judge\Delta{\tau'}{"type"}$}
\RightLabel{($\alpha\notin\Delta,\ \mathrm{pure}(e)$)}
\TernaryInfC{$\judge{\Delta;\Gamma}{\unpack e{[\alpha,x]}{e'}}{\subst{\tau'}{e.\alpha}\alpha}$}
\DisplayProof
\end{gather*}
%
%\[
%\Rule{\Delta ;\Gamma\force e:\exists\alpha.\sigma \quad \Delta ,\alpha\dty"type"; \Gamma, x\ty \sigma \force  e':\tau' \quad \Delta  \force  \tau'::"type" \quad \alpha \notin \Delta  \quad pure(e)}
%{\Delta ; \Gamma \force  \unpack{e}{[\alpha,x]}{e'}:\subst{\tau'}{e.\alpha}{\alpha}}
%\]
%
For example, if $R$ is a variable containing the existential encoding of
"Rational", above, and we read $R.x$ as syntactic sugar for
$\letin{[\alpha,m]}{R}{m.x}$, we can now typecheck a term such as
$\letin{c:R.t\to R.t\to R.t}{R.plus}{c(R.zero)(R.zero)}$, which has the type $R.t$.

One difficulty with allowing expressive module terms $e$ is that it
becomes hard to determine whether two types $e_1.\alpha$ and $e_2.\alpha$ are in
fact the same type. It is hard, of course, because determining
equality of terms in an expressive language is undecidable.

\section{DeMorgan's Laws}

Constructively, $\exists X.\phi\Rightarrow\neg\forall X.\neg\phi$ (but not conversely).
This suggests that there should be
a translation from existentials to universals, which is in fact true.
Weak existential types can be encoded using universal types in System
F, showing that there is an interesting duality between data
abstraction and polymorphism.
