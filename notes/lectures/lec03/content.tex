\lecture{3}
\title{$\lambda$-Calculus Encodings}
\date{1 February 2016}
\maketitle

Even though the pure $\lambda$-calculus consists only of $\lambda$-terms, we can represent and manipulate common data objects like integers, Boolean values, lists, and trees.  All these things can be encoded as $\lambda$-terms.

\section{Encoding Common Datatypes}

\subsection{Booleans}

The Booleans are the easiest to encode, so let us start with them.  We would like to define $\lambda$-terms to represent the Boolean constants \TRUE\ and \FALSE\ and the usual Boolean operators $\Rightarrow$ (if-then), $\wedge$ (and), $\vee$ (or), and $\neg$ (not) so that they behave in the expected way.  There are many reasonable encodings.  One good one is to define \TRUE\ and \FALSE\ by:
\begin{align*}
\TRUE\ &\definedas\ \lam{xy}{x} &
\FALSE\ &\definedas \lam{xy}{y}.
\end{align*}

Now we would like to define a conditional test \IF.  We would like \IF\ to take three arguments $b,t,f$, where $b$ is a Boolean value (either \TRUE\ or \FALSE) and $t,f$ are arbitrary $\lambda$-terms.  The function should return $t$ if $b=\TRUE$ and $f$ if $b=\FALSE$.
\begin{eqnarray*}
\IF &=& \lam{\mathit{btf}}{\left\{\begin{array}{ll}
t, & \mbox{if $b=\TRUE$},\\
f, & \mbox{if $b=\FALSE$}.
\end{array}\right.}
\end{eqnarray*}
Now the reason for defining \TRUE\ and \FALSE\ the way we did becomes clear.  Since $\TRUE\,t\,f\stepsone t$ and $\FALSE\,t\,f\stepsone f$, all $\IF$ has to do is apply its Boolean argument to the other two arguments:
\begin{eqnarray*}
\IF &\definedas& \lam{\mathit{btf}}{\mathit{btf}}
\end{eqnarray*}

The other Boolean operators can be defined from \IF:
\begin{align*}
\AND\ &\definedas\ \lam{b_1b_2}{\IF\,b_1\,b_2\,\FALSE} &
\OR\ &\definedas\ \lam{b_1b_2}{\IF\,b_1\,\TRUE\;b_2} &
\NOT\ &\definedas\ \lam{b_1}{\IF\,b_1\,\FALSE\;\TRUE}
\end{align*}

Whereas these operators work correctly when given Boolean values as we have defined them, all bets are off if they are applied to any other $\lambda$-term.  There is no guarantee of any kind of reasonable behavior.  Basically, with the untyped $\lambda$-calculus, it is _garbage in, garbage out_.

\subsection{Natural Numbers}

We will encode natural numbers $\naturals$ using _Church numerals_.  This is the same encoding that Alonzo Church used, although there are other reasonable encodings.  The Church numeral for the number $n\in\naturals$ is denoted $\overline n$.  It is the $\lambda$-term $\lam{fx}{f^n\,x}$, where $f^n$ denotes the $n$-fold composition of $f$ with itself:
\begin{eqnarray*}
\overline 0 &\definedas& \lam{fx}{f^0x}\ \ =\ \ \lam{fx}{x}\\
\overline 1 &\definedas& \lam{fx}{f^1x}\ \ =\ \ \lam{fx}{fx}\\
\overline 2 &\definedas& \lam{fx}{f^2x}\ \ =\ \ \lam{fx}{f(fx)}\\
\overline 3 &\definedas& \lam{fx}{f^3x}\ \ =\ \ \lam{fx}{f(f(fx))}\\
&\vdots\\
\overline n &\definedas& \lam{fx}{f^nx}\ \ =\ \ \lam{fx}{\underbrace{f(f(\ldots(f}_nx)\ldots))}
\end{eqnarray*}

We can define the successor function \SUCC\ as
\begin{eqnarray*}
\SUCC &\definedas& \lam{nfx}{f\,(n\,f\,x)}.
\end{eqnarray*}
That is, \SUCC\ on input $\overline n$ returns a function that takes a function $f$ as input, applies $\overline n$ to it to get the $n$-fold composition of $f$ with itself, then composes that with one more $f$ to get the $(n+1)$-fold composition of $f$ with itself.  Then
\begin{eqnarray*}
\SUCC\,\overline n &=& (\lam{nfx}{f(nfx)})\,\overline n\\
&\stepsone& \lam{fx}{f(\overline nfx)}\\
&\stepsone& \lam{fx}{f(f^nx)}\\
&=& \lam{fx}{f^{n+1}x}\\
&=& \overline{n+1}.
\end{eqnarray*}

We can perform basic arithmetic with Church numerals.  For addition, we might define
\begin{eqnarray*}
\ADD &\definedas& \lam{m\kern1ptnfx}{mf(nfx)}.
\end{eqnarray*}
On input $\overline m$ and $\overline n$, this function returns
\begin{eqnarray*}
(\lam{m\kern1ptnfx}{mf(nfx)})\,\overline m\,\overline n
&\stepsone& \lam{fx}{\overline mf(\overline nfx)}\\
&\stepsone& \lam{fx}{f^{m}(f^{n}x)}\\
&=& \lam{fx}{f^{m+n}x}\\
&=& \overline{m+n}.
\end{eqnarray*}
Here we are composing $f^{m}$ with $f^{n}$ to get $f^{m+n}$.

Alternatively, recall that Church numerals act on a function to apply that function repeatedly, and addition can be viewed as repeated application of the successor function, so we could define
\begin{eqnarray*}
\ADD &\definedas& \lam{mn}{m\,\SUCC\;n}.
\end{eqnarray*}

Similarly, multiplication is just iterated addition, and exponentiation is iterated multiplication:
\begin{eqnarray*}
\MUL\ \ \definedas\ \ \lam{mn}{m\kern1pt(\ADD\,n)\,\overline 0} &\quad& \EXP\ \ \definedas\ \ \lam{mn}{m\kern1pt(\MUL\,n)\,\overline 1}.
\end{eqnarray*}

\subsection{Pairing and Projections}

Logic and arithmetic are good places to start, but we still are lacking any useful data structures.  For example, consider ordered pairs.  It would be nice to have a pairing function \PAIR\ with projections \FIRST\ and \SECOND\ that obeyed the following equational specifications:
\begin{align*} 
\FIRST\,(\PAIR\,e_1\,e_2)\ &=\ e_1 &
\SECOND\,(\PAIR\,e_1\,e_2)\ &=\ e_2 &
\PAIR\,(\FIRST\,p)\,(\SECOND\,p)\ &=\ p,
\end{align*}
provided $p$ is a pair.  We can take a hint from \IF.  Recall that \IF\ selects one of its two branch options depending on its Boolean argument.  \PAIR\ can do something similar, wrapping its two arguments for later extraction by some function $f$:
\begin{eqnarray*} 
\PAIR &\definedas& \lam{\mathit{abf}}{\mathit{fab}}.
\end{eqnarray*}
Thus $\PAIR\,e_1\,e_2 \rightarrow \lam{f}{fe_1e_2}$.
To get $e_1$ back out, we can just apply this to \TRUE: $(\lam{f}{fe_1e_2})\,\TRUE \rightarrow \TRUE\,e_1\,e_2\rightarrow e_1$, and similarly applying it to \FALSE\ extracts $e_2$.  Thus we can define
\begin{eqnarray*}
\FIRST\ \ \definedas\ \ \lam{p}{p\,\TRUE} &\quad& \SECOND\ \ \definedas\ \ \lam{p}{p\,\FALSE}.
\end{eqnarray*}
Again, if $p$ is not a term of the form $\PAIR\,a\,b$, expect the unexpected.

\subsection{Lists}

One can define lists $[x_1;\,\ldots;\,x_n]$ and list operators corresponding to the OCaml \texttt{::}, \texttt{List.hd}, and \texttt{List.tl} in the $\lambda$-calculus.  We leave these constructions as exercises.

\subsection{Local Variables}

One feature that seems to be missing is the ability to declare local
variables. For example, in OCaml, we can introduce a new local
variable with the "let" expression:
\[
\letin x{e_1}{e_2}
\]
Intuitively, we expect this expression to evaluate $e_1$ to some value
$v$ and then to replace occurrences of $x$ inside $e_2$ with $v$.
In other words, it should evaluate to $\subst{e_2}vx$. But we
can construct a $\lambda$-term that behaves the same way:
\begin{align*}
(\lam x{e_2})\,e_1\ \rightarrow\ (\lam x{e_2})\,v\ \stepsone\ \subst{e_2}vx.
\end{align*}
We can thus view a "let" expression as syntactic sugar for an application of a $\lambda$-abstraction.

\nocite{Barendregt84}
