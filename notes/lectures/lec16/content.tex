\lecture{16}
\title{Hoare Logic}
\date{8 March 2016}
\maketitle

\section{Axiomatic Semantics}

So far we have focused on _operational semantics_, which are natural for
modeling computation or talking about how state changes from one step
of the computation to the next. In operational semantics, there is a
well-defined notion of _state_. We take great pains to say exactly what
a state is and how it is manipulated by a program.

In _axiomatic semantics_, on the other hand, we do not so much care what
the states actually are, but only the properties that we can observe
about them. This approach emphasizes the relationship between the properties of the
input (preconditions) and properties of the output (postconditions).
This approach is useful for specifying what a program is supposed to do and talk
about a program's correctness with respect to that specification.

\section{Preconditions and Postconditions}

The _preconditions_ and _postconditions_ of a program
say what is true before and after the program
executes, respectively. Often the correctness of the program
is specified in these terms. Typically this is expressed as a contract: as long
as the caller guarantees that the initial state satisfies some set of preconditions, then
the program will guarantee that the final state will satisfy some
desired set of postconditions. Axiomatic semantics attempts to say exactly
what preconditions are necessary for ensuring a given set of postconditions.

\section{An Example}

Consider the following program to compute $x^p$:

\medskip

\begin{flushleft}
$\phantom{ddd}\assg y1$;\\
$\phantom{ddd}\assg q0$;\\
$\phantom{ddd}"while"~q \lt p~\{$\\
$\phantom{ddddd}\assg y{y\cdot x}$;\\
$\phantom{ddddd}\assg q{q+1}$;\\
$\phantom{ddd}\}$
\end{flushleft}

\medskip\noindent
The desired postcondition we would like to ensure is $y=x^p$; that is, the
final value of the program variable $y$ is the $p$th power of $x$. We would
also like to ensure that the program halts. One
essential precondition needed to ensure halting is $p \ge 0$, because the program
will only halt and compute $x^p$ correctly if that holds. Note that $p \gt 0$ will also
guarantee that the program halts and produces the correct output,
but this is a stronger condition (is satisfied by fewer states, has more logical consequences).
\begin{eqnarray*}
\underbrace{p \gt 0}_{\mathrm{stronger}} &\Rightarrow& \underbrace{p \ge 0}_{\mathrm{weaker}}
\end{eqnarray*}
The weaker precondition is better because it is less restrictive of the
possible starting values of $p$ that ensure correctness. Typically, given a
postcondition expressing a desired property of the output state, we would
like to know the _weakest precondition_ that guarantees that the program
halts and satisfies that postcondition upon termination.

\section{Partial vs Total Correctness}

Two approaches to program verification are:
\begin{itemize}
\item _Partial correctness_: check if program is correct when it terminates. This is characterized by "wlp" and the Hoare logic we will define shortly. The termination issue is handled separately.
\item _Total correctness_: ensure both that the program terminates and that it is correct. This is characterized by "wp".
\end{itemize}
Partial correctness is the more common approach, since it separates the two issues of correctness and termination. These two verification tasks use very different methods, and it is helpful to separate them. Often partial correctness is easier to establish, and once this is done, the correctness conditions can be used in conjunction with a well-founded relation to establish termination.

\section{Syntax of Hoare Logic}

To define Hoare logic, we need to define the well-formed formulas in the logic. Hoare logic is built on top of another conventional logic, such as first-order logic. For now, let us take first-order logic as our base logic. Let $\phi,\psi,\ldots$ denote first-order formulas. The formulas of Hoare logic are _partial correctness assertions_ (PCA's), also known as _Hoare triples_. They look like
\[
\PCA\phi c\psi.
\]
Informally, this means, ``if $\phi$ holds before execution of $c$, and if $c$ terminates, then $\psi$ will hold upon termination.'' This is equivalent to
\(
\phi &\Imp& \wlp c\psi.
\)

\subsection{Proof Rules}

We will discuss the semantics of Hoare logic later. For now, we just give the deduction rules for the language \IMP\ with programs
\begin{eqnarray*}
c & ::= & "skip" \bnf \assg xa \bnf \comp{c_0}{c_1} \bnf \ifthenelse b{c_1}{c_2} \bnf \whiledo bc
\end{eqnarray*}
The rules are
\settowidth\tl{(sequential composition) }
\begin{enumerate}
\item[] \parbox\tl{("skip")} $\PCA\phi{"skip"}\phi$
\item[] \parbox\tl{(assignment)} $\PCA{\subst\phi ax}{\assg xa}\phi$
\item[] \parbox\tl{(sequential composition)} $\displaystyle\frac{\PCA\phi{c_1}\psi\quad\PCA\psi{c_2}\sigma}{\PCA\phi{\comp{c_1}{c_2}}\sigma}$
\item[] \parbox\tl{(conditional)} $\displaystyle\frac{\PCA{b\wedge\phi}{c_1}\psi\quad\PCA{\neg b\wedge\phi}{c_2}\psi}{\PCA\phi{\ifthenelse b{c_1}{c_2}}\psi}$
\item[] \parbox\tl{(while)} $\displaystyle\frac{\PCA{b\wedge\phi}c\phi}{\PCA\phi{\whiledo bc}{\phi\wedge\neg b}}$
\item[] \parbox\tl{(weakening)} $\displaystyle\frac{\phi\Imp\phi'\quad\PCA{\phi'}c{\psi'}\quad\psi'\Imp\psi}{\PCA\phi c\psi}$.
\end{enumerate}
In the assignment rule, $\subst\phi ax$ denotes the safe substitution of the arithmetic expression $a$ for the variable $x$ in $\phi$. As with the $\lambda$-calculus, there may be bound variables in $\phi$ bound by quantifiers $\forall$ and $\exists$, and these may have to be renamed to avoid capturing the free variables of $a$. In the weakening rule, the operator $\Imp$ is implication in the underlying logic. Note the parallels between these rules and the definitions of "wlp".

\section{Soundness and Completeness}

A deduction system defines what it means for a formula to be _provable_, whereas a semantics defines what it means for a formula to be _true_. Given a logic with a semantics and a deduction system, two desirable properties are
\begin{itemize}
\item _Soundness_: Every provable formula is true.
\item _Completeness_: Every true formula is provable.
\end{itemize}

Soundness is a basic requirement of any logical system. A logic would not be good for much if its theorems were false! With respect to the small-step or big-step semantics of \IMP, Hoare logic is sound.

Completeness, on the other hand, is a much more difficult issue. Hoare logic, as presented, is not complete in general. However, it is _relatively complete_ given an oracle for truth in the underlying logic, provided that logic is expressive enough to express weakest preconditions. This is a famous result of Stephen Cook. Although first-order logic is not expressive enough to express weakest preconditions over arbitrary domains of computation, it is expressive enough over $\naturals$ or $\integers$. Therefore Hoare logic is relatively complete for \IMP\ programs over the integers.

\section{Semantics of IMP Revisited}

Recall from an earlier lecture the big-step operational rules of \IMP\ and their characterization in terms of binary relations on states $\sigma:\Var\to\integers$. The big-step rules are

\settowidth\tl{(sequential composition)}
\begin{itemize}
\item[]
\parbox\tl{(\SKIP)}
\begin{tabular}c
$\config{\SKIP}{\sigma}\stepsto\sigma$
\end{tabular}
\item[]
\parbox\tl{(assignment)}
\begin{tabular}{c}
\infer{\config{\assg xa}{\sigma}\stepsto\rebind\sigma nx}{\config{a}{\sigma}\stepsto n}
\end{tabular}
\item[]
\parbox\tl{(sequential composition)}
\begin{tabular}{c}
\infer{\config{\comp{c_0}{c_1}}{\sigma}\stepsto\rho}
{\config{c_0}{\sigma}\stepsto\tau\quad\config{c_1}{\tau}\stepsto\rho}
\end{tabular}
\item[]
\parbox\tl{(conditional)}
\begin{tabular}{cc}
\infer{\config{\ifthenelse b{c_1}{c_2}}{\sigma}\stepsto\tau}
{\config{b}{\sigma}\stepsto \TRUE\quad\config{c_1}{\sigma}\stepsto\tau} &
\infer{\config{\ifthenelse b{c_1}{c_2}}{\sigma}\stepsto\tau}
{\config{b}{\sigma}\stepsto \FALSE\quad\config{c_2}{\sigma}\stepsto\tau}
\end{tabular}
\item[]
\parbox\tl{(while loop)}
\begin{tabular}{cc}
\infer{\config{\whiledo bc}{\sigma}\stepsto\sigma}
 {\config{b}{\sigma}\stepsto\FALSE} &
\infer{\config{\whiledo bc}{\sigma}\stepsto\rho}
 {\config{b}{\sigma}\stepsto\TRUE\quad\config{c}{\sigma}\stepsto\tau\quad\config{\whiledo bc}{\tau}\stepsto\rho}
\end{tabular}
\end{itemize}

Let \Env\ be the set of all states $\sigma:\Var\to\integers$. For each program $c$, the big-step rules determine a binary input/output relation on \Env, namely
\(
\SB c &\definedas& \{(\sigma,\tau) \mid \config{c}{\sigma}\stepsto\tau\}\ \ \subseteq\ \ \Env\times\Env.
\)
With this notation, we can express the big-step rules in terms of some basic operations on binary relations, namely _relational composition_ ($\circ$) and _reflexive transitive closure_ ($\rtc$):
\(
R\circ S &\definedas& \set{(\sigma,\rho)}{\exists \tau\ (\sigma,\tau)\in S,\ (\tau,\rho)\in R}\\
R\rtc &\definedas& \bigcup_{n\geq 0} R^n\ \ =\ \ \set{(\sigma,\tau)}{\exists \sigma_0,\ldots,\sigma_n\ \sigma=\sigma_0,\ \tau=\sigma_n,\ \mbox{and}\ (\sigma_i,\sigma_{i+1})\in R,\ 0\leq i\leq n-1},
\)
where $R^0\definedas\{(\sigma,\sigma) \mid \sigma\in\Env\}$ and $R^{n+1}\definedas R\circ R^n$. The big-step rules are equivalent to the following:
\begin{align*}
\SB{\SKIP} &= \{(\sigma,\sigma) \mid \sigma\in\Env\} && \text{(\SKIP)}\\[1ex]
\SB{\assg xa} &= \{(\sigma,\rebind\sigma nx) \mid \config{a}{\sigma}\stepsto n\} && \text{(assignment)}\\[1ex]
\SB{\comp{c_0}{c_1}} &= \SB{c_1}\circ\SB{c_0} && \text{(sequential composition)}\\[1ex]
\SB{\ifthenelse b{c_1}{c_2}} &= \SB{c_1}\circ\SB{b}\ \cup\ \SB{c_2}\circ\SB{\neg b} && \text{(conditional)}\\[1ex]
\SB{\whiledo bc} &= \SB{\neg b}\circ(\SB{c}\circ\SB{b})\rtc && \text{(while loop)},
\end{align*}
%\[\begin{array}{lrcl}
%\text{(\SKIP)} & \SB{\SKIP} &=& \{(\sigma,\sigma) \mid \sigma\in\Env\}\\[1ex]
%\text{(assignment)} & \SB{\assg xa} &=& \{(\sigma,\rebind\sigma nx) \mid \config{a}{\sigma}\stepsto n\}\\[1ex]
%\text{(sequential composition)} & \SB{\comp{c_0}{c_1}} &=& \SB{c_0}\circ\SB{c_1}\\[1ex]
%\text{(conditional)} & \SB{\ifthenelse b{c_1}{c_2}} &=& \SB{b}\circ\SB{c_1}\ \cup\ \SB{\neg b}\circ\SB{c_2}\\[1ex]
%\text{(while loop)} & \SB{\whiledo bc} &=& (\SB{b}\circ\SB{c})\rtc\circ\SB{\neg b},
%\end{array}\]
where in the conditional and while loop,
\(
\SB{b} &\definedas& \{(\sigma,\sigma) \mid \config{b}{\sigma}\stepsto\TRUE\}\\
\SB{\neg b} &\definedas& \{(\sigma,\sigma) \mid \config{b}{\sigma}\stepsto\FALSE\}\ \ =\ \ \SB{\SKIP} - \SB b.
\)
In fact, this would have been a much more compact way to define them originally.
