\lecture{9}
\title{Evaluation Contexts}
\date{19 February 2016}
\maketitle

\section{Evaluation Contexts}

The rules for structural operational semantics can be classified into two types:
\begin{itemize}
\item
\emph{reduction rules}, which describe the actual computation steps; and
\item
\emph{evaluation order rules}, which constrain the choice of reductions that can be performed next.
\end{itemize}

For example, the CBV reduction strategy for the $\lambda$-calculus is captured in the following three rules:
\begin{align}
 \frac{}{(\lam xe)\,v \rightarrow \subst evx} &&
 \frac{e_1 \rightarrow e'_1}{e_1\,e_2 \rightarrow e'_1\,e_2} &&
 \frac{e_2 \rightarrow e'_2}{v\,e_2 \rightarrow v\,e'_2}\label{eqn:rule2}
\end{align}
The leftmost rule is a reduction rule ($\beta$-reduction), whereas the other two rules are evaluation order rules. The evaluation order rules say essentially that a reduction may be applied to a redex on the left-hand side of an application anytime, and may be applied to a redex on the right-hand side of an application provided the left-hand side is already fully reduced.

Although there are only two evaluation order rules in the CBV $\lambda$-calculus, there are typically many more in real-world programming languages. This motivates the desire to find a more compact representation for such rules. 

\emph{Evaluation contexts} provide a mechanism to do just that. An evaluation context $E$, sometimes written $\contextHole$, is a $\lambda$-term or a metaexpression representing a family of $\lambda$-terms with a special variable $\hole$ called the \emph{hole}. If $\contextHole$ is an evaluation context, then $\context e$ represents $E$ with the term $e$ substituted for the hole.

Every evaluation context $\contextHole$ represents a _context rule_
\[
 \frac{e \rightarrow e'}{\context e \rightarrow \context{e'}},
\]
which says that we may apply the reduction $e\rightarrow e'$ in the context $\context e$.

For the case of the CBV $\lambda$-calculus, the rightmost two rules of \eqref{eqn:rule2} can be represented more compactly by the two evaluation context schemes $\hole\,e$ and $v\,\hole$. Thus we could specify the CBV $\lambda$-calculus simply by writing
\begin{align*}
 (\lam xe)\,v \rightarrow \subst evx && \hole\,e && v\,\hole.
\end{align*}
The CBN $\lambda$-calculus has an equally compact specification:
\begin{align*}
 (\lam xe)\,e' \rightarrow \subst e{e'}x && \hole\,e.
\end{align*}

\section{Nested Contexts}

Note that in CBV, the evaluation contexts $\hole\,e$ and $v\,\hole$ do not specify \emph{all} contexts in which $\beta$-reduction may be applied. There are also compound contexts obtained from nested applications of the rules \eqref{eqn:rule2}. For example, the context
\begin{equation}
 (v\,\hole)\,e\label{eqn:nested}
\end{equation}
is also a valid evaluation context for CBV, since it can be derived from two applications of the rules \eqref{eqn:rule2}:
\begin{equation}
\AxiomC{$e_1 \rightarrow e_2$}
\UnaryInfC{$v\,e_1 \rightarrow v\,e_2$}
\UnaryInfC{$(v\,e_1)\,e \rightarrow (v\,e_2)\,e$}
\DisplayProof
\label{eqn:nested2}
\end{equation}
Here we have applied the rightmost rule of \eqref{eqn:rule2} in the first step and the middle rule of \eqref{eqn:rule2} in the second. The evaluation context \eqref{eqn:nested} represents the abbreviated rule
\[
 \frac
 {e_1 \rightarrow e_2}
 {(v\,e_1)\,e \rightarrow (v\,e_2)\,e}
\]
obtained by collapsing the two steps of \eqref{eqn:nested2}.

The set of \emph{all} valid evaluation contexts for the CBV $\lambda$-calculus is represented by the grammar
\begin{eqnarray*}
 E &::=& \hole \bnf E\,e \bnf v\,E.
\end{eqnarray*}

\section{Annotated Proof Trees}

We can also use evaluation contexts to indicate exactly where a reduction is applied in each step of a proof tree. For example, consider the annotated proof tree
\[
 \infer[\ (\hole\,\lam z{zz})]{(\lam xx)\,((\lam xx)\,0)\,\lam z{zz}\rightarrow(\lam xx)\,0\,\lam z{zz}}
 {\infer[\ ((\lam xx)\,\hole)]{(\lam xx)\,((\lam xx)\,0)\rightarrow(\lam xx)\,0}{(\lam xx)\,0 \rightarrow 0}}
\]
We have labeled each step to indicate the context in which the $\beta$-reduction was applied.

As above, we can simplify the tree by collapsing the two steps and annotating the resulting abbreviated tree with the corresponding nested context:
\[
 \infer[\ ((\lam xx)\,\hole\,\lam z{zz})]{(\lam xx)\,((\lam xx)\,0)\,\lam z{zz}\rightarrow(\lam xx)\,0\,\lam z{zz}}
 {(\lam xx)\,0 \rightarrow 0}
\]

\section{Error Propagation}

Evaluation contexts can be used to define the semantics of error exceptions. If we have a special error value $\mathsf{error}$, we can very easily propagate it using the evaluation order rule
\[
 \context{\mathsf{error}} \rightarrow \mathsf{error}.
\]
This obviates the need to show in painstaking detail how error propagates up through a series of applications of rewrite rules. We will revisit this idea later on when we talk about exception handling mechanisms.

The benefits of evaluation contexts will become exceedingly clear in the future as we add more features to the language.

\section{Semantics via Translation}

Our goal is to study programming language features using various
semantic techniques. So far we have seen small-step and big-step
operational semantics. However, there are other ways to specify
meaning, and they can give useful insights that may not be apparent in
the operational semantics.

A different way to give semantics is by defining a _translation_ from
the programming language to another language that is better understood
(and typically simpler). This is essentially a process
of \emph{compilation}, in which a source language is converted to a
target language.  Later on we will see that the target language can
even be mathematical structures, in which case we refer to the
semantics as a _denotational semantics_. A third style of semantics is
_axiomatic semantics_, which we will also discuss later in the course.

We map well-formed programs in the original language into items in
a \emph{meaning space}. These items may be

\begin{itemize}
\item programs in an another language (definitional translation);
\item mathematical objects (denotational semantics); an example is taking $\lam{x:\mathsf{int}}x$ to $\{(0,0),\,(1,1),\,\ldots\}$.
\end{itemize}

Because they define the meaning of a program, these translations are
also known as \emph{meaning functions} or \emph{semantic functions}. We
usually denote the semantic function under consideration by $\SB\cdot$.
An object $e$ in the original language is mapped to an object $\SB e$ in
the meaning space under the semantic function. We may occasionally add
other decorations to distinguish between different semantic functions, as
for example $\SB e_{\mathrm{cbn}}$ or $\SB[C]e$.

\section{Translating CBN $\lambda$-Calculus into CBV $\lambda$-Calculus}

The call-by-name (lazy) $\lambda$-calculus was defined with the
following reduction rule and evaluation contexts:
\begin{eqnarray*}
(\lam x{e_1})\,e_2\ \stepsone\ \subst{e_1}{e_2}x
&\quad&
E\ ::=\ \hole \bnf E\,e.
\end{eqnarray*}
The call-by-value (eager) $\lambda$-calculus was similarly defined with
\begin{eqnarray*}
(\lam xe)\,v\ \stepsone\ \subst evx
&\quad&
E\ ::=\ \hole \bnf E\,e \bnf v\,E.
\end{eqnarray*}

These are fine as operational semantics, but the CBN semantics rules
do not adequately capture why CBV is as expressive as CBN.
We can see this more clearly by constructing a translation from CBN to CBV.
That is, we treat the CBV calculus as the meaning space.
This translation exposes some issues that need to be addressed when
implementing a lazy language.

To translate from the CBN $\lambda$-calculus to the CBV $\lambda$-calculus,
the key issue is how to make function application lazy in the arguments.
CBV evaluation will eagerly evaluate all the argument expressions, so
they need to be protected from evaluation. This is accomplished by
wrapping the expressions passed as function arguments inside
$\lambda$-abstractions to delay their evaluation. When the value of a
variable is really needed, the abstraction can be passed a dummy parameter
to evaluate its body.

We define the semantic function $\SB{\cdot}$ by
induction on the structure of the translated expression:
\begin{eqnarray*}
\SB x &\definedas& x~\ID \qquad (\ID = \lam zz)    \\
\SB{\lam xe} &\definedas& \lam x{\SB e}        \\
\SB{e_1\,e_2} &\definedas& \SB{e_1}\,(\lam z{\SB{e_2}}),
  \quad\mbox{where $z\notin\FV{\SB{e_2}}$.}
\end{eqnarray*}

For an example, recall that we defined: 
\begin{align*}
\TRUE\ &\definedas\ \lam{xy}x & \FALSE\ &\definedas\ \lam{xy}y & \IF\ &\definedas\ \lam{xyz}xyz.
\end{align*}

The problem with this construction in the CBV $\lambda$-calculus is that
$\IF\,b\,e_1\,e_2$ evaluates both $e_1$ and $e_2$, regardless of the truth
value of $b$. The conversion above fixes this problem.
\begin{align*}
\SB{\TRUE} &= \SB{\lam{xy}x} = \lam{xy}{\SB x} = \lam{xy}{x~\ID}\\
\SB{\FALSE} &= \SB{\lam{xy}y} = \lam{xy}{\SB y} = \lam{xy}{y~\ID}\\
\SB{\IF} &= \SB{\lam{xyz}{xyz}} = \lam{xyz}{\SB{(xy)z}} = \lam{xyz}{\SB{xy}~(\lam d{\SB z}})\\
&= \lam{xyz}{\SB x~(\lam d{\SB y})~(\lam d{\SB z}})\\
&= \lam{xyz}{(x~\ID)~(\lam d{y~\ID})~(\lam d{z~\ID}}).
\end{align*}
Now, translating $\IF\,\TRUE\,e_1\,e_2$ and evaluating under the CBV rules,
\begin{eqnarray*}
\SB{\IF\,\TRUE\,e_1\,e_2}
&=& \SB{\IF}\,(\lam d{\SB{\TRUE}})\,(\lam d{\SB{e_1}})\,(\lam d{\SB{e_2}})\\
&=& (\lam{xyz}{(x\,\ID)\,(\lam d{y\,\ID})\,(\lam d{z\,\ID})})\,(\lam d{\SB{\TRUE}})\,(\lam d{\SB{e_1}})\,(\lam d{\SB{e_2}})\\
&\stepsthree& ((\lam d{\SB{\TRUE}})\,\ID)\,(\lam d{(\lam d{\SB{e_1}})\,\ID})\,(\lam d{(\lam d{\SB{e_2}})\,\ID})\\
&\stepsone& {\SB{\TRUE}}\,(\lam d{(\lam d{\SB{e_1}})\,\ID})\,(\lam d{(\lam d{\SB{e_2}})\,\ID})\\
&=& (\lam{xy}{x\,\ID})\,(\lam d{(\lam d{\SB{e_1}})\,\ID})\,(\lam d{(\lam d{\SB{e_2}})\,\ID})\\
&\stepstwo& ({(\lam d{(\lam d{\SB{e_1}})\,\ID})\,\ID})\\
&\stepstwo& \SB{e_1},
\end{eqnarray*}
and $e_2$ was never evaluated.
