\lecture{13}
\title{State}
\date{29 February 2016}
\maketitle

\section{Introduction}

_Program state_ refers to the ability to change the values of program variables over time.
The $\lambda$-calculus and the \FL\ language do not have state in the sense that once a variable
is bound to a value, it is impossible to change that value as long as the variable is in scope.
Although state is not a necessary feature of a programming language---for example,
the $\lambda$-calculus is Turing complete but does not have a notion of state---it is
a common feature of most languages, and most programmers are accustomed to it.

\section{Programming Paradigms}

Two major programming paradigms are \emph{functional} (stateless) and \emph{imperative} (stateful).
In a purely functional language, expressions resemble mathematical formulas.  This allows the programmer to
reason equationally, avoiding many of the pitfalls associated with
a constantly changing execution environment.  For example, in a functional
language, it is always the case that
\begin{eqnarray*}
x = e &\Imp& f(x) = f(e).
\end{eqnarray*}
Concurrency is easier to implement with a functional language because
of confluence (aka the Church--Rosser property).

On the other hand, imperative programming more closely resembles the way we perceive the real
world in that there exists an underlying notion of \emph{state} that can change
over time.  We have seen an example of state and imperative programming with
the language \IMP.

\section{References}

\emph{References} (aka \emph{pointers}) provide another
level of mutable state.  References can be updated in a way that cannot be handled by the
simple substitution rules of their functional counterparts.  They are somewhat more
complicated than ordinary variable bindings because they introduce the extra complication
of \emph{aliasing}---the possibility of naming the same data value with different names.

For example, consider the following code:
\begin{code}
   let x = ref 1 in
   let y = x in
   x := 2; !y
\end{code}
The first $x$ points to a newly allocated location holding the value 1.  Then $y$ is assigned $x$, the pointer to the location holding 1.  Then the value pointed to by $x$ is updated to be 2.  When $y$ is dereferenced with $!y$, the result is now 2.  Here $x$ and $y$ are aliases for the same data value.  When you kick $x$, $y$ jumps!

Reference should not be confused with mutable variables. A variable is \emph{mutable} if its
binding can change. The difference is subtle: variables are bound to values in an environment,
and if the variable is mutable, it can be rebound to a different value. With references, the variable
itself is bound to a \emph{location}. The location is mutable (it can be rebound to a different value)
but the variable itself is immutable.
In \IMP\ and imperative languages such as C, variables are typically mutable, whereas in functional
languages such as \FL\ and OCaml, they are typically not.

\section{The \FL! Language}

\subsection{Syntax}
The syntax for \FL! is as follows.  There is a countable set \Loc\ of \emph{memory locations}, denoted generically by $\ell$, that can hold data values.  All \FL\ expressions are \FL! expressions.  In addition, there are a few more:
\begin{eqnarray*}
e &::=& \ldots \bnf "ref"\,e \bnf !\kern1pte \bnf \assg{e_1}{e_2} \bnf \comp{e_1}{e_2} \bnf \ell
\end{eqnarray*}

\subsection{The Store}

We define a \emph{store} as a partial function $\sigma: \Loc\pfun\Val$
with finite domain.  A store is very much like an environment, except
that variables are bound to locations, not to the data values
themselves, and the locations are bound to data values.

As in the last lecture, we write $\rebind\sigma v\ell$ refers to the
store $\sigma$ with the location $\ell$ changed to contain the value
$v$, if $\ell\in\dom\sigma$, otherwise it refers to $\sigma$ with the
new location $\ell$ containing value $v$ added to $\dom\sigma$.

\subsection{Small-Step Semantics}

A program in \FL! is a configuration $\config e\sigma$, where $e$ is an \FL! expression and $\sigma$ is a store.  The small-step SOS is given by augmenting \FL\ with the following additional evaluation contexts and reduction rules:
\begin{eqnarray*}
E & ::= & \ldots \bnf "ref"\,E \bnf !\,E \bnf \assg Ee \bnf \assg vE \bnf \comp Ee
\end{eqnarray*}
The hole $\hole$ is already included in the \ldots~.  The evaluation contexts generated by the above grammar are all the contexts $E\hole$ in which a reduction may be applied.  The contexts specify a family of rules collectively called the \emph{context rule}
\[
\frac{\p e\sigma \rightarrow \p{e'}{\sigma'}}{\p{\context e}\sigma \rightarrow \p{\context{e'}}{\sigma'}}
\]
The reduction rules are
\[
\begin{array}{c@{\hspace{1cm}}c}
\p{"ref"~v}\sigma \rightarrow \p\ell{\sigma[v/\ell]},\ \ell\notin\dom\sigma &
\p{!\ell}\sigma \rightarrow \p{\sigma(\ell)}\sigma,\ \ell\in\dom\sigma\\[2pt]
\p{\ell := v}\sigma \rightarrow \p{"null"}{\sigma[v/\ell]},\ \ell\in\dom\sigma &
\p{v;e}\sigma \rightarrow \p e\sigma.
\end{array}
\]
It can be shown by induction that it is impossible to create dangling pointers in \FL!.

\section{Translating \FL! to \FL}

To translate \FL! to \FL, we need a way to encode stores that supports
a number of operations including finding fresh locations. One way to
do this is to encode locations as integers and stores $\sigma$ as
pairs whose first component represents the next free location and
whose second component is a function from integers to values:
\begin{eqnarray*}
"lookup"~\sigma~\ell &=& (\#2\,\sigma)(\ell)\\
"update"\ \sigma\ \ell\ v &=& \rebind{(\#2\,\sigma)} v\ell\\
"malloc"\ \sigma\ v &=& \letin{\ell}{\#1\,\sigma}{
(\ell,\,(\#1\,\sigma + 1, \rebind{(\#2\,\sigma)} v\ell))}\\
\EMPTY &=& (0, \lam{x}{"error"})\\
\end{eqnarray*}

\renewcommand\p[2]{(#1,#2)}

Using this encoding, we can define the following translation, which
maps an \FL! expression $e$ to a function $\SB e$ taking an
environment $\rho$ and store $\sigma$ and producing an \FL\ pair
$\p{e'}{\sigma'}$, where $e'$ is an \FL\ expression and $\sigma'$ is a
store.

Here $\letin{\p b{\sigma'}}{\SBB{e_0}\rho\sigma}{\ldots}$ is syntactic
sugar for
\[
\letin x{\SBB{e_0}\rho\sigma}{\letin b{\#1~x}{\letin{\sigma'}{\#2~x}{\ldots}}}~.
\]
\begin{eqnarray*}
\SBB n\rho\sigma &=& \p n\sigma\\
\SBB x\rho\sigma &=& \p{\lookup\rho x}\sigma\\
\SBB{\ifthenelse{e_0}{e_1}{e_2}}\rho\sigma &=&
\letin{\p b{\sigma'}}{\SBB{e_0}\rho\sigma}\\
&& \ifthenelse b{\SBB{e_1}\rho{\sigma'}}{\SBB{e_2}\rho{\sigma'}}\\
\SBB{"ref"~e}\rho\sigma &=& \letin{\p v{\sigma'}}{\SBB e\rho\sigma}{"malloc"\,{\sigma'}\,v}\\
\SBB{!e}\rho\sigma &=& \letin{\p\ell{\sigma'}}{\SBB e\rho\sigma}{\p{"lookup"\,{\sigma'}\,\ell}{\sigma'}}\\
\SBB{\assg{e_1}{e_2}}\rho\sigma &=& \letin{\p{\ell}{\sigma_1}}{\SBB{e_1}\rho\sigma}{}\\
&& \letin{\p{v}{\sigma_2}}{\SBB{e_2}\rho{\sigma_1}}{}\\
&& \p{"null"}{"update"~{\sigma_2}~{\ell}~{v}}\\
\SBB{\comp{e_1}{e_2}}\rho\sigma &=& \letin{\p x{\sigma_1}}{\SBB{e_1}\rho\sigma}{\SBB{e_2}\rho{\sigma_1}}\\
\SBB{\lam xe}{\rho_{\mathrm{lex}}}{\sigma_{\mathrm{lex}}} &=&
\p{\lam{v\sigma_{\mathrm{dyn}}}{\SBB e{(\update{\rho_{\mathrm{lex}}}vx)}{\sigma_{\mathrm{dyn}}}}}{\sigma_{\mathrm{lex}}}\\
\SBB{e_1~e_2}{\rho_{\mathrm{dyn}}}{\sigma_{\mathrm{dyn}}} &=&
\letin{\p f{\sigma_1}}{\SBB{e_1}{\rho_{\mathrm{dyn}}}{\sigma_{\mathrm{dyn}}}}{}\\
&& \letin{\p v{\sigma_2}}{\SBB{e_2}{\rho_{\mathrm{dyn}}}{\sigma_1}}{}\\
&& f~v~\sigma_2
\end{eqnarray*}

Note that the translation is not actually sound---e.g., consider
dereferencing a location that is not in the domain of the store. We
can repair this flaw by simply preventing locations from appearing in
source programs and modifying the statement of the soundness lemmas in
corresponding ways.
